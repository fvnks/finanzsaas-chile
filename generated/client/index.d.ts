
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model CostCenter
 * 
 */
export type CostCenter = $Result.DefaultSelection<Prisma.$CostCenterPayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model Crew
 * 
 */
export type Crew = $Result.DefaultSelection<Prisma.$CrewPayload>
/**
 * Model JobTitle
 * 
 */
export type JobTitle = $Result.DefaultSelection<Prisma.$JobTitlePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model DailyReport
 * 
 */
export type DailyReport = $Result.DefaultSelection<Prisma.$DailyReportPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentRequirement
 * 
 */
export type DocumentRequirement = $Result.DefaultSelection<Prisma.$DocumentRequirementPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model ClientMonthlyInfo
 * 
 */
export type ClientMonthlyInfo = $Result.DefaultSelection<Prisma.$ClientMonthlyInfoPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanMark
 * 
 */
export type PlanMark = $Result.DefaultSelection<Prisma.$PlanMarkPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.costCenter`: Exposes CRUD operations for the **CostCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCenters
    * const costCenters = await prisma.costCenter.findMany()
    * ```
    */
  get costCenter(): Prisma.CostCenterDelegate<ExtArgs>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<ExtArgs>;

  /**
   * `prisma.jobTitle`: Exposes CRUD operations for the **JobTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobTitles
    * const jobTitles = await prisma.jobTitle.findMany()
    * ```
    */
  get jobTitle(): Prisma.JobTitleDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.dailyReport`: Exposes CRUD operations for the **DailyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyReports
    * const dailyReports = await prisma.dailyReport.findMany()
    * ```
    */
  get dailyReport(): Prisma.DailyReportDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.documentRequirement`: Exposes CRUD operations for the **DocumentRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentRequirements
    * const documentRequirements = await prisma.documentRequirement.findMany()
    * ```
    */
  get documentRequirement(): Prisma.DocumentRequirementDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs>;

  /**
   * `prisma.clientMonthlyInfo`: Exposes CRUD operations for the **ClientMonthlyInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientMonthlyInfos
    * const clientMonthlyInfos = await prisma.clientMonthlyInfo.findMany()
    * ```
    */
  get clientMonthlyInfo(): Prisma.ClientMonthlyInfoDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.planMark`: Exposes CRUD operations for the **PlanMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanMarks
    * const planMarks = await prisma.planMark.findMany()
    * ```
    */
  get planMark(): Prisma.PlanMarkDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.0
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    Client: 'Client',
    Project: 'Project',
    CostCenter: 'CostCenter',
    Worker: 'Worker',
    Crew: 'Crew',
    JobTitle: 'JobTitle',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    DailyReport: 'DailyReport',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    Document: 'Document',
    DocumentRequirement: 'DocumentRequirement',
    Material: 'Material',
    InventoryMovement: 'InventoryMovement',
    ClientMonthlyInfo: 'ClientMonthlyInfo',
    Plan: 'Plan',
    PlanMark: 'PlanMark'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "company" | "client" | "project" | "costCenter" | "worker" | "crew" | "jobTitle" | "invoice" | "invoiceItem" | "dailyReport" | "purchaseOrder" | "purchaseOrderItem" | "document" | "documentRequirement" | "material" | "inventoryMovement" | "clientMonthlyInfo" | "plan" | "planMark"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      CostCenter: {
        payload: Prisma.$CostCenterPayload<ExtArgs>
        fields: Prisma.CostCenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findFirst: {
            args: Prisma.CostCenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          findMany: {
            args: Prisma.CostCenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          create: {
            args: Prisma.CostCenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          createMany: {
            args: Prisma.CostCenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
          }
          delete: {
            args: Prisma.CostCenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          update: {
            args: Prisma.CostCenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          deleteMany: {
            args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostCenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCenterPayload>
          }
          aggregate: {
            args: Prisma.CostCenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostCenter>
          }
          groupBy: {
            args: Prisma.CostCenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostCenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCenterCountArgs<ExtArgs>
            result: $Utils.Optional<CostCenterCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      Crew: {
        payload: Prisma.$CrewPayload<ExtArgs>
        fields: Prisma.CrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findFirst: {
            args: Prisma.CrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findMany: {
            args: Prisma.CrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          create: {
            args: Prisma.CrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          createMany: {
            args: Prisma.CrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          delete: {
            args: Prisma.CrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          update: {
            args: Prisma.CrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          deleteMany: {
            args: Prisma.CrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          aggregate: {
            args: Prisma.CrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrew>
          }
          groupBy: {
            args: Prisma.CrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewCountArgs<ExtArgs>
            result: $Utils.Optional<CrewCountAggregateOutputType> | number
          }
        }
      }
      JobTitle: {
        payload: Prisma.$JobTitlePayload<ExtArgs>
        fields: Prisma.JobTitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobTitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobTitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          findFirst: {
            args: Prisma.JobTitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobTitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          findMany: {
            args: Prisma.JobTitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>[]
          }
          create: {
            args: Prisma.JobTitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          createMany: {
            args: Prisma.JobTitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobTitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>[]
          }
          delete: {
            args: Prisma.JobTitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          update: {
            args: Prisma.JobTitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          deleteMany: {
            args: Prisma.JobTitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobTitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobTitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobTitlePayload>
          }
          aggregate: {
            args: Prisma.JobTitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobTitle>
          }
          groupBy: {
            args: Prisma.JobTitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobTitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobTitleCountArgs<ExtArgs>
            result: $Utils.Optional<JobTitleCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      DailyReport: {
        payload: Prisma.$DailyReportPayload<ExtArgs>
        fields: Prisma.DailyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          findFirst: {
            args: Prisma.DailyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          findMany: {
            args: Prisma.DailyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>[]
          }
          create: {
            args: Prisma.DailyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          createMany: {
            args: Prisma.DailyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>[]
          }
          delete: {
            args: Prisma.DailyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          update: {
            args: Prisma.DailyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          deleteMany: {
            args: Prisma.DailyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReportPayload>
          }
          aggregate: {
            args: Prisma.DailyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyReport>
          }
          groupBy: {
            args: Prisma.DailyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyReportCountArgs<ExtArgs>
            result: $Utils.Optional<DailyReportCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentRequirement: {
        payload: Prisma.$DocumentRequirementPayload<ExtArgs>
        fields: Prisma.DocumentRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          findFirst: {
            args: Prisma.DocumentRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          findMany: {
            args: Prisma.DocumentRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>[]
          }
          create: {
            args: Prisma.DocumentRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          createMany: {
            args: Prisma.DocumentRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>[]
          }
          delete: {
            args: Prisma.DocumentRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          update: {
            args: Prisma.DocumentRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          deleteMany: {
            args: Prisma.DocumentRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRequirementPayload>
          }
          aggregate: {
            args: Prisma.DocumentRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentRequirement>
          }
          groupBy: {
            args: Prisma.DocumentRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentRequirementCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      ClientMonthlyInfo: {
        payload: Prisma.$ClientMonthlyInfoPayload<ExtArgs>
        fields: Prisma.ClientMonthlyInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientMonthlyInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientMonthlyInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          findFirst: {
            args: Prisma.ClientMonthlyInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientMonthlyInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          findMany: {
            args: Prisma.ClientMonthlyInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>[]
          }
          create: {
            args: Prisma.ClientMonthlyInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          createMany: {
            args: Prisma.ClientMonthlyInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientMonthlyInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>[]
          }
          delete: {
            args: Prisma.ClientMonthlyInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          update: {
            args: Prisma.ClientMonthlyInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          deleteMany: {
            args: Prisma.ClientMonthlyInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientMonthlyInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientMonthlyInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMonthlyInfoPayload>
          }
          aggregate: {
            args: Prisma.ClientMonthlyInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientMonthlyInfo>
          }
          groupBy: {
            args: Prisma.ClientMonthlyInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientMonthlyInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientMonthlyInfoCountArgs<ExtArgs>
            result: $Utils.Optional<ClientMonthlyInfoCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanMark: {
        payload: Prisma.$PlanMarkPayload<ExtArgs>
        fields: Prisma.PlanMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanMarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanMarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          findFirst: {
            args: Prisma.PlanMarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanMarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          findMany: {
            args: Prisma.PlanMarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>[]
          }
          create: {
            args: Prisma.PlanMarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          createMany: {
            args: Prisma.PlanMarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanMarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>[]
          }
          delete: {
            args: Prisma.PlanMarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          update: {
            args: Prisma.PlanMarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          deleteMany: {
            args: Prisma.PlanMarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanMarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanMarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMarkPayload>
          }
          aggregate: {
            args: Prisma.PlanMarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanMark>
          }
          groupBy: {
            args: Prisma.PlanMarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanMarkCountArgs<ExtArgs>
            result: $Utils.Optional<PlanMarkCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    companies: number
    dailyReports: number
    planMarks: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    dailyReports?: boolean | UserCountOutputTypeCountDailyReportsArgs
    planMarks?: boolean | UserCountOutputTypeCountPlanMarksArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlanMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMarkWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    clients: number
    projects: number
    invoices: number
    documents: number
    requirements: number
    monthlyInfo: number
    workers: number
    crews: number
    purchaseOrders: number
    inventoryMovements: number
    costCenters: number
    DailyReport: number
    Material: number
    Plan: number
    jobTitles: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    clients?: boolean | CompanyCountOutputTypeCountClientsArgs
    projects?: boolean | CompanyCountOutputTypeCountProjectsArgs
    invoices?: boolean | CompanyCountOutputTypeCountInvoicesArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    requirements?: boolean | CompanyCountOutputTypeCountRequirementsArgs
    monthlyInfo?: boolean | CompanyCountOutputTypeCountMonthlyInfoArgs
    workers?: boolean | CompanyCountOutputTypeCountWorkersArgs
    crews?: boolean | CompanyCountOutputTypeCountCrewsArgs
    purchaseOrders?: boolean | CompanyCountOutputTypeCountPurchaseOrdersArgs
    inventoryMovements?: boolean | CompanyCountOutputTypeCountInventoryMovementsArgs
    costCenters?: boolean | CompanyCountOutputTypeCountCostCentersArgs
    DailyReport?: boolean | CompanyCountOutputTypeCountDailyReportArgs
    Material?: boolean | CompanyCountOutputTypeCountMaterialArgs
    Plan?: boolean | CompanyCountOutputTypeCountPlanArgs
    jobTitles?: boolean | CompanyCountOutputTypeCountJobTitlesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRequirementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMonthlyInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientMonthlyInfoWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCostCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDailyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJobTitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobTitleWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    projects: number
    invoices: number
    documents: number
    requirements: number
    monthlyInfo: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ClientCountOutputTypeCountProjectsArgs
    invoices?: boolean | ClientCountOutputTypeCountInvoicesArgs
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
    requirements?: boolean | ClientCountOutputTypeCountRequirementsArgs
    monthlyInfo?: boolean | ClientCountOutputTypeCountMonthlyInfoArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRequirementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMonthlyInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientMonthlyInfoWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    crews: number
    invoices: number
    dailyReports: number
    documents: number
    purchaseOrders: number
    inventoryMovements: number
    plans: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crews?: boolean | ProjectCountOutputTypeCountCrewsArgs
    invoices?: boolean | ProjectCountOutputTypeCountInvoicesArgs
    dailyReports?: boolean | ProjectCountOutputTypeCountDailyReportsArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    purchaseOrders?: boolean | ProjectCountOutputTypeCountPurchaseOrdersArgs
    inventoryMovements?: boolean | ProjectCountOutputTypeCountInventoryMovementsArgs
    plans?: boolean | ProjectCountOutputTypeCountPlansArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDailyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReportWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }


  /**
   * Count Type CostCenterCountOutputType
   */

  export type CostCenterCountOutputType = {
    invoices: number
    plans: number
  }

  export type CostCenterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | CostCenterCountOutputTypeCountInvoicesArgs
    plans?: boolean | CostCenterCountOutputTypeCountPlansArgs
  }

  // Custom InputTypes
  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenterCountOutputType
     */
    select?: CostCenterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    crews: number
    planMarks: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crews?: boolean | WorkerCountOutputTypeCountCrewsArgs
    planMarks?: boolean | WorkerCountOutputTypeCountPlanMarksArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountPlanMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMarkWhereInput
  }


  /**
   * Count Type CrewCountOutputType
   */

  export type CrewCountOutputType = {
    workers: number
  }

  export type CrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | CrewCountOutputTypeCountWorkersArgs
  }

  // Custom InputTypes
  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     */
    select?: CrewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    relatedByInvoices: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    relatedByInvoices?: boolean | InvoiceCountOutputTypeCountRelatedByInvoicesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountRelatedByInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Count Type DocumentRequirementCountOutputType
   */

  export type DocumentRequirementCountOutputType = {
    documents: number
  }

  export type DocumentRequirementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | DocumentRequirementCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentRequirementCountOutputType without action
   */
  export type DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirementCountOutputType
     */
    select?: DocumentRequirementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentRequirementCountOutputType without action
   */
  export type DocumentRequirementCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    movements: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | MaterialCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    marks: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marks?: boolean | PlanCountOutputTypeCountMarksArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMarkWhereInput
  }


  /**
   * Count Type PlanMarkCountOutputType
   */

  export type PlanMarkCountOutputType = {
    workers: number
  }

  export type PlanMarkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | PlanMarkCountOutputTypeCountWorkersArgs
  }

  // Custom InputTypes
  /**
   * PlanMarkCountOutputType without action
   */
  export type PlanMarkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMarkCountOutputType
     */
    select?: PlanMarkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanMarkCountOutputType without action
   */
  export type PlanMarkCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    activeCompanyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    activeCompanyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    allowedSections: number
    assignedProjectIds: number
    activeCompanyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    activeCompanyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    activeCompanyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    allowedSections?: true
    assignedProjectIds?: true
    activeCompanyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: string
    allowedSections: string[]
    assignedProjectIds: string[]
    activeCompanyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    allowedSections?: boolean
    assignedProjectIds?: boolean
    activeCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companies?: boolean | User$companiesArgs<ExtArgs>
    dailyReports?: boolean | User$dailyReportsArgs<ExtArgs>
    planMarks?: boolean | User$planMarksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    allowedSections?: boolean
    assignedProjectIds?: boolean
    activeCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    allowedSections?: boolean
    assignedProjectIds?: boolean
    activeCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | User$companiesArgs<ExtArgs>
    dailyReports?: boolean | User$dailyReportsArgs<ExtArgs>
    planMarks?: boolean | User$planMarksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      companies: Prisma.$CompanyPayload<ExtArgs>[]
      dailyReports: Prisma.$DailyReportPayload<ExtArgs>[]
      planMarks: Prisma.$PlanMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: string
      allowedSections: string[]
      assignedProjectIds: string[]
      activeCompanyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    dailyReports<T extends User$dailyReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findMany"> | Null>
    planMarks<T extends User$planMarksArgs<ExtArgs> = {}>(args?: Subset<T, User$planMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly allowedSections: FieldRef<"User", 'String[]'>
    readonly assignedProjectIds: FieldRef<"User", 'String[]'>
    readonly activeCompanyId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * User.dailyReports
   */
  export type User$dailyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    where?: DailyReportWhereInput
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    cursor?: DailyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * User.planMarks
   */
  export type User$planMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    where?: PlanMarkWhereInput
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    cursor?: PlanMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    rut: number
    name: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    rut: string
    name: string
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    projects?: boolean | Company$projectsArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    requirements?: boolean | Company$requirementsArgs<ExtArgs>
    monthlyInfo?: boolean | Company$monthlyInfoArgs<ExtArgs>
    workers?: boolean | Company$workersArgs<ExtArgs>
    crews?: boolean | Company$crewsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    inventoryMovements?: boolean | Company$inventoryMovementsArgs<ExtArgs>
    costCenters?: boolean | Company$costCentersArgs<ExtArgs>
    DailyReport?: boolean | Company$DailyReportArgs<ExtArgs>
    Material?: boolean | Company$MaterialArgs<ExtArgs>
    Plan?: boolean | Company$PlanArgs<ExtArgs>
    jobTitles?: boolean | Company$jobTitlesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    rut?: boolean
    name?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    projects?: boolean | Company$projectsArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    requirements?: boolean | Company$requirementsArgs<ExtArgs>
    monthlyInfo?: boolean | Company$monthlyInfoArgs<ExtArgs>
    workers?: boolean | Company$workersArgs<ExtArgs>
    crews?: boolean | Company$crewsArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    inventoryMovements?: boolean | Company$inventoryMovementsArgs<ExtArgs>
    costCenters?: boolean | Company$costCentersArgs<ExtArgs>
    DailyReport?: boolean | Company$DailyReportArgs<ExtArgs>
    Material?: boolean | Company$MaterialArgs<ExtArgs>
    Plan?: boolean | Company$PlanArgs<ExtArgs>
    jobTitles?: boolean | Company$jobTitlesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      requirements: Prisma.$DocumentRequirementPayload<ExtArgs>[]
      monthlyInfo: Prisma.$ClientMonthlyInfoPayload<ExtArgs>[]
      workers: Prisma.$WorkerPayload<ExtArgs>[]
      crews: Prisma.$CrewPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      costCenters: Prisma.$CostCenterPayload<ExtArgs>[]
      DailyReport: Prisma.$DailyReportPayload<ExtArgs>[]
      Material: Prisma.$MaterialPayload<ExtArgs>[]
      Plan: Prisma.$PlanPayload<ExtArgs>[]
      jobTitles: Prisma.$JobTitlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rut: string
      name: string
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    clients<T extends Company$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Company$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Company$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Company$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Company$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    requirements<T extends Company$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    monthlyInfo<T extends Company$monthlyInfoArgs<ExtArgs> = {}>(args?: Subset<T, Company$monthlyInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findMany"> | Null>
    workers<T extends Company$workersArgs<ExtArgs> = {}>(args?: Subset<T, Company$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany"> | Null>
    crews<T extends Company$crewsArgs<ExtArgs> = {}>(args?: Subset<T, Company$crewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Company$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryMovements<T extends Company$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany"> | Null>
    costCenters<T extends Company$costCentersArgs<ExtArgs> = {}>(args?: Subset<T, Company$costCentersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany"> | Null>
    DailyReport<T extends Company$DailyReportArgs<ExtArgs> = {}>(args?: Subset<T, Company$DailyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findMany"> | Null>
    Material<T extends Company$MaterialArgs<ExtArgs> = {}>(args?: Subset<T, Company$MaterialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany"> | Null>
    Plan<T extends Company$PlanArgs<ExtArgs> = {}>(args?: Subset<T, Company$PlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany"> | Null>
    jobTitles<T extends Company$jobTitlesArgs<ExtArgs> = {}>(args?: Subset<T, Company$jobTitlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly rut: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.clients
   */
  export type Company$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Company.projects
   */
  export type Company$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Company.invoices
   */
  export type Company$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Company.requirements
   */
  export type Company$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    where?: DocumentRequirementWhereInput
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    cursor?: DocumentRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * Company.monthlyInfo
   */
  export type Company$monthlyInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    where?: ClientMonthlyInfoWhereInput
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    cursor?: ClientMonthlyInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientMonthlyInfoScalarFieldEnum | ClientMonthlyInfoScalarFieldEnum[]
  }

  /**
   * Company.workers
   */
  export type Company$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Company.crews
   */
  export type Company$crewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Company.purchaseOrders
   */
  export type Company$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Company.inventoryMovements
   */
  export type Company$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Company.costCenters
   */
  export type Company$costCentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    cursor?: CostCenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * Company.DailyReport
   */
  export type Company$DailyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    where?: DailyReportWhereInput
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    cursor?: DailyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * Company.Material
   */
  export type Company$MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Company.Plan
   */
  export type Company$PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Company.jobTitles
   */
  export type Company$jobTitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    where?: JobTitleWhereInput
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    cursor?: JobTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    rut: number
    name: number
    email: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    rut: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    projects?: boolean | Client$projectsArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    requirements?: boolean | Client$requirementsArgs<ExtArgs>
    monthlyInfo?: boolean | Client$monthlyInfoArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    rut?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Client$projectsArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    requirements?: boolean | Client$requirementsArgs<ExtArgs>
    monthlyInfo?: boolean | Client$monthlyInfoArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      requirements: Prisma.$DocumentRequirementPayload<ExtArgs>[]
      monthlyInfo: Prisma.$ClientMonthlyInfoPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rut: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Client$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Client$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Client$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    requirements<T extends Client$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Client$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    monthlyInfo<T extends Client$monthlyInfoArgs<ExtArgs> = {}>(args?: Subset<T, Client$monthlyInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly rut: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly companyId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.projects
   */
  export type Client$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Client.invoices
   */
  export type Client$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Client.requirements
   */
  export type Client$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    where?: DocumentRequirementWhereInput
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    cursor?: DocumentRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * Client.monthlyInfo
   */
  export type Client$monthlyInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    where?: ClientMonthlyInfoWhereInput
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    cursor?: ClientMonthlyInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientMonthlyInfoScalarFieldEnum | ClientMonthlyInfoScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    progress: number | null
    budget: number | null
  }

  export type ProjectSumAggregateOutputType = {
    progress: number | null
    budget: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    clientId: string | null
    progress: number | null
    budget: number | null
    address: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    clientId: string | null
    progress: number | null
    budget: number | null
    address: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    clientId: number
    progress: number
    budget: number
    address: number
    startDate: number
    endDate: number
    workerIds: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    progress?: true
    budget?: true
  }

  export type ProjectSumAggregateInputType = {
    progress?: true
    budget?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    clientId?: true
    progress?: true
    budget?: true
    address?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    clientId?: true
    progress?: true
    budget?: true
    address?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    clientId?: true
    progress?: true
    budget?: true
    address?: true
    startDate?: true
    endDate?: true
    workerIds?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    clientId: string | null
    progress: number
    budget: number
    address: string | null
    startDate: Date | null
    endDate: Date | null
    workerIds: string[]
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    progress?: boolean
    budget?: boolean
    address?: boolean
    startDate?: boolean
    endDate?: boolean
    workerIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    crews?: boolean | Project$crewsArgs<ExtArgs>
    invoices?: boolean | Project$invoicesArgs<ExtArgs>
    dailyReports?: boolean | Project$dailyReportsArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    purchaseOrders?: boolean | Project$purchaseOrdersArgs<ExtArgs>
    inventoryMovements?: boolean | Project$inventoryMovementsArgs<ExtArgs>
    plans?: boolean | Project$plansArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    progress?: boolean
    budget?: boolean
    address?: boolean
    startDate?: boolean
    endDate?: boolean
    workerIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | Project$clientArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    clientId?: boolean
    progress?: boolean
    budget?: boolean
    address?: boolean
    startDate?: boolean
    endDate?: boolean
    workerIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    crews?: boolean | Project$crewsArgs<ExtArgs>
    invoices?: boolean | Project$invoicesArgs<ExtArgs>
    dailyReports?: boolean | Project$dailyReportsArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    purchaseOrders?: boolean | Project$purchaseOrdersArgs<ExtArgs>
    inventoryMovements?: boolean | Project$inventoryMovementsArgs<ExtArgs>
    plans?: boolean | Project$plansArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Project$clientArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      crews: Prisma.$CrewPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      dailyReports: Prisma.$DailyReportPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      plans: Prisma.$PlanPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      clientId: string | null
      progress: number
      budget: number
      address: string | null
      startDate: Date | null
      endDate: Date | null
      workerIds: string[]
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Project$clientArgs<ExtArgs> = {}>(args?: Subset<T, Project$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    crews<T extends Project$crewsArgs<ExtArgs> = {}>(args?: Subset<T, Project$crewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Project$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Project$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    dailyReports<T extends Project$dailyReportsArgs<ExtArgs> = {}>(args?: Subset<T, Project$dailyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Project$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Project$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryMovements<T extends Project$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Project$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany"> | Null>
    plans<T extends Project$plansArgs<ExtArgs> = {}>(args?: Subset<T, Project$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly progress: FieldRef<"Project", 'Int'>
    readonly budget: FieldRef<"Project", 'Float'>
    readonly address: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly workerIds: FieldRef<"Project", 'String[]'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly companyId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.client
   */
  export type Project$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Project.crews
   */
  export type Project$crewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Project.invoices
   */
  export type Project$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Project.dailyReports
   */
  export type Project$dailyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    where?: DailyReportWhereInput
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    cursor?: DailyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Project.purchaseOrders
   */
  export type Project$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Project.inventoryMovements
   */
  export type Project$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Project.plans
   */
  export type Project$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model CostCenter
   */

  export type AggregateCostCenter = {
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  export type CostCenterAvgAggregateOutputType = {
    budget: number | null
  }

  export type CostCenterSumAggregateOutputType = {
    budget: number | null
  }

  export type CostCenterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    budget: number | null
    createAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CostCenterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    budget: number | null
    createAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CostCenterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    budget: number
    createAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CostCenterAvgAggregateInputType = {
    budget?: true
  }

  export type CostCenterSumAggregateInputType = {
    budget?: true
  }

  export type CostCenterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    budget?: true
    createAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CostCenterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    budget?: true
    createAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CostCenterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    budget?: true
    createAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CostCenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenter to aggregate.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCenters
    **/
    _count?: true | CostCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostCenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostCenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCenterMaxAggregateInputType
  }

  export type GetCostCenterAggregateType<T extends CostCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCenter[P]>
      : GetScalarType<T[P], AggregateCostCenter[P]>
  }




  export type CostCenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCenterWhereInput
    orderBy?: CostCenterOrderByWithAggregationInput | CostCenterOrderByWithAggregationInput[]
    by: CostCenterScalarFieldEnum[] | CostCenterScalarFieldEnum
    having?: CostCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCenterCountAggregateInputType | true
    _avg?: CostCenterAvgAggregateInputType
    _sum?: CostCenterSumAggregateInputType
    _min?: CostCenterMinAggregateInputType
    _max?: CostCenterMaxAggregateInputType
  }

  export type CostCenterGroupByOutputType = {
    id: string
    code: string
    name: string
    budget: number
    createAt: Date
    updatedAt: Date
    companyId: string
    _count: CostCenterCountAggregateOutputType | null
    _avg: CostCenterAvgAggregateOutputType | null
    _sum: CostCenterSumAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  type GetCostCenterGroupByPayload<T extends CostCenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
            : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
        }
      >
    >


  export type CostCenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    budget?: boolean
    createAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    invoices?: boolean | CostCenter$invoicesArgs<ExtArgs>
    plans?: boolean | CostCenter$plansArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | CostCenterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    budget?: boolean
    createAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCenter"]>

  export type CostCenterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    budget?: boolean
    createAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CostCenterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | CostCenter$invoicesArgs<ExtArgs>
    plans?: boolean | CostCenter$plansArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | CostCenterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostCenterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CostCenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostCenter"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      plans: Prisma.$PlanPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      budget: number
      createAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["costCenter"]>
    composites: {}
  }

  type CostCenterGetPayload<S extends boolean | null | undefined | CostCenterDefaultArgs> = $Result.GetResult<Prisma.$CostCenterPayload, S>

  type CostCenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostCenterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostCenterCountAggregateInputType | true
    }

  export interface CostCenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostCenter'], meta: { name: 'CostCenter' } }
    /**
     * Find zero or one CostCenter that matches the filter.
     * @param {CostCenterFindUniqueArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostCenterFindUniqueArgs>(args: SelectSubset<T, CostCenterFindUniqueArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostCenter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostCenterFindUniqueOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostCenterFindUniqueOrThrowArgs>(args: SelectSubset<T, CostCenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostCenterFindFirstArgs>(args?: SelectSubset<T, CostCenterFindFirstArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostCenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstOrThrowArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostCenterFindFirstOrThrowArgs>(args?: SelectSubset<T, CostCenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCenters
     * const costCenters = await prisma.costCenter.findMany()
     * 
     * // Get first 10 CostCenters
     * const costCenters = await prisma.costCenter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostCenterFindManyArgs>(args?: SelectSubset<T, CostCenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostCenter.
     * @param {CostCenterCreateArgs} args - Arguments to create a CostCenter.
     * @example
     * // Create one CostCenter
     * const CostCenter = await prisma.costCenter.create({
     *   data: {
     *     // ... data to create a CostCenter
     *   }
     * })
     * 
     */
    create<T extends CostCenterCreateArgs>(args: SelectSubset<T, CostCenterCreateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostCenters.
     * @param {CostCenterCreateManyArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCenterCreateManyArgs>(args?: SelectSubset<T, CostCenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostCenters and returns the data saved in the database.
     * @param {CostCenterCreateManyAndReturnArgs} args - Arguments to create many CostCenters.
     * @example
     * // Create many CostCenters
     * const costCenter = await prisma.costCenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostCenters and only return the `id`
     * const costCenterWithIdOnly = await prisma.costCenter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCenterCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostCenter.
     * @param {CostCenterDeleteArgs} args - Arguments to delete one CostCenter.
     * @example
     * // Delete one CostCenter
     * const CostCenter = await prisma.costCenter.delete({
     *   where: {
     *     // ... filter to delete one CostCenter
     *   }
     * })
     * 
     */
    delete<T extends CostCenterDeleteArgs>(args: SelectSubset<T, CostCenterDeleteArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostCenter.
     * @param {CostCenterUpdateArgs} args - Arguments to update one CostCenter.
     * @example
     * // Update one CostCenter
     * const costCenter = await prisma.costCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostCenterUpdateArgs>(args: SelectSubset<T, CostCenterUpdateArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostCenters.
     * @param {CostCenterDeleteManyArgs} args - Arguments to filter CostCenters to delete.
     * @example
     * // Delete a few CostCenters
     * const { count } = await prisma.costCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostCenterDeleteManyArgs>(args?: SelectSubset<T, CostCenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostCenterUpdateManyArgs>(args: SelectSubset<T, CostCenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostCenter.
     * @param {CostCenterUpsertArgs} args - Arguments to update or create a CostCenter.
     * @example
     * // Update or create a CostCenter
     * const costCenter = await prisma.costCenter.upsert({
     *   create: {
     *     // ... data to create a CostCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCenter we want to update
     *   }
     * })
     */
    upsert<T extends CostCenterUpsertArgs>(args: SelectSubset<T, CostCenterUpsertArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterCountArgs} args - Arguments to filter CostCenters to count.
     * @example
     * // Count the number of CostCenters
     * const count = await prisma.costCenter.count({
     *   where: {
     *     // ... the filter for the CostCenters we want to count
     *   }
     * })
    **/
    count<T extends CostCenterCountArgs>(
      args?: Subset<T, CostCenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCenterAggregateArgs>(args: Subset<T, CostCenterAggregateArgs>): Prisma.PrismaPromise<GetCostCenterAggregateType<T>>

    /**
     * Group by CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCenterGroupByArgs['orderBy'] }
        : { orderBy?: CostCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostCenter model
   */
  readonly fields: CostCenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostCenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends CostCenter$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, CostCenter$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    plans<T extends CostCenter$plansArgs<ExtArgs> = {}>(args?: Subset<T, CostCenter$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostCenter model
   */ 
  interface CostCenterFieldRefs {
    readonly id: FieldRef<"CostCenter", 'String'>
    readonly code: FieldRef<"CostCenter", 'String'>
    readonly name: FieldRef<"CostCenter", 'String'>
    readonly budget: FieldRef<"CostCenter", 'Float'>
    readonly createAt: FieldRef<"CostCenter", 'DateTime'>
    readonly updatedAt: FieldRef<"CostCenter", 'DateTime'>
    readonly companyId: FieldRef<"CostCenter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CostCenter findUnique
   */
  export type CostCenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findUniqueOrThrow
   */
  export type CostCenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter findFirst
   */
  export type CostCenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findFirstOrThrow
   */
  export type CostCenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenter to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     */
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter findMany
   */
  export type CostCenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter, which CostCenters to fetch.
     */
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     */
    orderBy?: CostCenterOrderByWithRelationInput | CostCenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCenters.
     */
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     */
    skip?: number
    distinct?: CostCenterScalarFieldEnum | CostCenterScalarFieldEnum[]
  }

  /**
   * CostCenter create
   */
  export type CostCenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The data needed to create a CostCenter.
     */
    data: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
  }

  /**
   * CostCenter createMany
   */
  export type CostCenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCenter createManyAndReturn
   */
  export type CostCenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostCenters.
     */
    data: CostCenterCreateManyInput | CostCenterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostCenter update
   */
  export type CostCenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The data needed to update a CostCenter.
     */
    data: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
    /**
     * Choose, which CostCenter to update.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter updateMany
   */
  export type CostCenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostCenters.
     */
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter upsert
   */
  export type CostCenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * The filter to search for the CostCenter to update in case it exists.
     */
    where: CostCenterWhereUniqueInput
    /**
     * In case the CostCenter found by the `where` argument doesn't exist, create a new CostCenter with this data.
     */
    create: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
    /**
     * In case the CostCenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
  }

  /**
   * CostCenter delete
   */
  export type CostCenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    /**
     * Filter which CostCenter to delete.
     */
    where: CostCenterWhereUniqueInput
  }

  /**
   * CostCenter deleteMany
   */
  export type CostCenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCenters to delete
     */
    where?: CostCenterWhereInput
  }

  /**
   * CostCenter.invoices
   */
  export type CostCenter$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * CostCenter.plans
   */
  export type CostCenter$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * CostCenter without action
   */
  export type CostCenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    experienceYears: number | null
  }

  export type WorkerSumAggregateOutputType = {
    experienceYears: number | null
  }

  export type WorkerMinAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    role: string | null
    specialty: string | null
    email: string | null
    phone: string | null
    experienceYears: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: string | null
    rut: string | null
    name: string | null
    role: string | null
    specialty: string | null
    email: string | null
    phone: string | null
    experienceYears: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    rut: number
    name: number
    role: number
    specialty: number
    email: number
    phone: number
    experienceYears: number
    certifications: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    experienceYears?: true
  }

  export type WorkerSumAggregateInputType = {
    experienceYears?: true
  }

  export type WorkerMinAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    role?: true
    specialty?: true
    email?: true
    phone?: true
    experienceYears?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    role?: true
    specialty?: true
    email?: true
    phone?: true
    experienceYears?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    rut?: true
    name?: true
    role?: true
    specialty?: true
    email?: true
    phone?: true
    experienceYears?: true
    certifications?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: string
    rut: string
    name: string
    role: string | null
    specialty: string | null
    email: string | null
    phone: string | null
    experienceYears: number | null
    certifications: string[]
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    role?: boolean
    specialty?: boolean
    email?: boolean
    phone?: boolean
    experienceYears?: boolean
    certifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    crews?: boolean | Worker$crewsArgs<ExtArgs>
    planMarks?: boolean | Worker$planMarksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rut?: boolean
    name?: boolean
    role?: boolean
    specialty?: boolean
    email?: boolean
    phone?: boolean
    experienceYears?: boolean
    certifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    rut?: boolean
    name?: boolean
    role?: boolean
    specialty?: boolean
    email?: boolean
    phone?: boolean
    experienceYears?: boolean
    certifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crews?: boolean | Worker$crewsArgs<ExtArgs>
    planMarks?: boolean | Worker$planMarksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      crews: Prisma.$CrewPayload<ExtArgs>[]
      planMarks: Prisma.$PlanMarkPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rut: string
      name: string
      role: string | null
      specialty: string | null
      email: string | null
      phone: string | null
      experienceYears: number | null
      certifications: string[]
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crews<T extends Worker$crewsArgs<ExtArgs> = {}>(args?: Subset<T, Worker$crewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany"> | Null>
    planMarks<T extends Worker$planMarksArgs<ExtArgs> = {}>(args?: Subset<T, Worker$planMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */ 
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'String'>
    readonly rut: FieldRef<"Worker", 'String'>
    readonly name: FieldRef<"Worker", 'String'>
    readonly role: FieldRef<"Worker", 'String'>
    readonly specialty: FieldRef<"Worker", 'String'>
    readonly email: FieldRef<"Worker", 'String'>
    readonly phone: FieldRef<"Worker", 'String'>
    readonly experienceYears: FieldRef<"Worker", 'Int'>
    readonly certifications: FieldRef<"Worker", 'String[]'>
    readonly createdAt: FieldRef<"Worker", 'DateTime'>
    readonly updatedAt: FieldRef<"Worker", 'DateTime'>
    readonly companyId: FieldRef<"Worker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker.crews
   */
  export type Worker$crewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Worker.planMarks
   */
  export type Worker$planMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    where?: PlanMarkWhereInput
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    cursor?: PlanMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model Crew
   */

  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    role: number
    projectId: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crew to aggregate.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithAggregationInput | CrewOrderByWithAggregationInput[]
    by: CrewScalarFieldEnum[] | CrewScalarFieldEnum
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }

  export type CrewGroupByOutputType = {
    id: string
    name: string
    role: string | null
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | Crew$projectArgs<ExtArgs>
    workers?: boolean | Crew$workersArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | Crew$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Crew$projectArgs<ExtArgs>
    workers?: boolean | Crew$workersArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Crew$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crew"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      workers: Prisma.$WorkerPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string | null
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["crew"]>
    composites: {}
  }

  type CrewGetPayload<S extends boolean | null | undefined | CrewDefaultArgs> = $Result.GetResult<Prisma.$CrewPayload, S>

  type CrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrewCountAggregateInputType | true
    }

  export interface CrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crew'], meta: { name: 'Crew' } }
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrewFindUniqueArgs>(args: SelectSubset<T, CrewFindUniqueArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Crew that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs>(args: SelectSubset<T, CrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrewFindFirstArgs>(args?: SelectSubset<T, CrewFindFirstArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs>(args?: SelectSubset<T, CrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrewFindManyArgs>(args?: SelectSubset<T, CrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
     */
    create<T extends CrewCreateArgs>(args: SelectSubset<T, CrewCreateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Crews.
     * @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrewCreateManyArgs>(args?: SelectSubset<T, CrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crews and returns the data saved in the database.
     * @param {CrewCreateManyAndReturnArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crews and only return the `id`
     * const crewWithIdOnly = await prisma.crew.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrewCreateManyAndReturnArgs>(args?: SelectSubset<T, CrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
     */
    delete<T extends CrewDeleteArgs>(args: SelectSubset<T, CrewDeleteArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrewUpdateArgs>(args: SelectSubset<T, CrewUpdateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrewDeleteManyArgs>(args?: SelectSubset<T, CrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrewUpdateManyArgs>(args: SelectSubset<T, CrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
     */
    upsert<T extends CrewUpsertArgs>(args: SelectSubset<T, CrewUpsertArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): Prisma.PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crew model
   */
  readonly fields: CrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Crew$projectArgs<ExtArgs> = {}>(args?: Subset<T, Crew$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workers<T extends Crew$workersArgs<ExtArgs> = {}>(args?: Subset<T, Crew$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crew model
   */ 
  interface CrewFieldRefs {
    readonly id: FieldRef<"Crew", 'String'>
    readonly name: FieldRef<"Crew", 'String'>
    readonly role: FieldRef<"Crew", 'String'>
    readonly projectId: FieldRef<"Crew", 'String'>
    readonly createdAt: FieldRef<"Crew", 'DateTime'>
    readonly updatedAt: FieldRef<"Crew", 'DateTime'>
    readonly companyId: FieldRef<"Crew", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Crew findUnique
   */
  export type CrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findFirst
   */
  export type CrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findMany
   */
  export type CrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crews to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew create
   */
  export type CrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to create a Crew.
     */
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }

  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crew createManyAndReturn
   */
  export type CrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Crew update
   */
  export type CrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to update a Crew.
     */
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
  }

  /**
   * Crew upsert
   */
  export type CrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The filter to search for the Crew to update in case it exists.
     */
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     */
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }

  /**
   * Crew delete
   */
  export type CrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter which Crew to delete.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crews to delete
     */
    where?: CrewWhereInput
  }

  /**
   * Crew.project
   */
  export type Crew$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Crew.workers
   */
  export type Crew$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Crew without action
   */
  export type CrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
  }


  /**
   * Model JobTitle
   */

  export type AggregateJobTitle = {
    _count: JobTitleCountAggregateOutputType | null
    _min: JobTitleMinAggregateOutputType | null
    _max: JobTitleMaxAggregateOutputType | null
  }

  export type JobTitleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type JobTitleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type JobTitleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type JobTitleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type JobTitleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type JobTitleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type JobTitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitle to aggregate.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobTitles
    **/
    _count?: true | JobTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobTitleMaxAggregateInputType
  }

  export type GetJobTitleAggregateType<T extends JobTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateJobTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobTitle[P]>
      : GetScalarType<T[P], AggregateJobTitle[P]>
  }




  export type JobTitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobTitleWhereInput
    orderBy?: JobTitleOrderByWithAggregationInput | JobTitleOrderByWithAggregationInput[]
    by: JobTitleScalarFieldEnum[] | JobTitleScalarFieldEnum
    having?: JobTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobTitleCountAggregateInputType | true
    _min?: JobTitleMinAggregateInputType
    _max?: JobTitleMaxAggregateInputType
  }

  export type JobTitleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: JobTitleCountAggregateOutputType | null
    _min: JobTitleMinAggregateOutputType | null
    _max: JobTitleMaxAggregateOutputType | null
  }

  type GetJobTitleGroupByPayload<T extends JobTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobTitleGroupByOutputType[P]>
            : GetScalarType<T[P], JobTitleGroupByOutputType[P]>
        }
      >
    >


  export type JobTitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | JobTitle$companyArgs<ExtArgs>
  }, ExtArgs["result"]["jobTitle"]>

  export type JobTitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | JobTitle$companyArgs<ExtArgs>
  }, ExtArgs["result"]["jobTitle"]>

  export type JobTitleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type JobTitleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | JobTitle$companyArgs<ExtArgs>
  }
  export type JobTitleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | JobTitle$companyArgs<ExtArgs>
  }

  export type $JobTitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobTitle"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["jobTitle"]>
    composites: {}
  }

  type JobTitleGetPayload<S extends boolean | null | undefined | JobTitleDefaultArgs> = $Result.GetResult<Prisma.$JobTitlePayload, S>

  type JobTitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobTitleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobTitleCountAggregateInputType | true
    }

  export interface JobTitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobTitle'], meta: { name: 'JobTitle' } }
    /**
     * Find zero or one JobTitle that matches the filter.
     * @param {JobTitleFindUniqueArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobTitleFindUniqueArgs>(args: SelectSubset<T, JobTitleFindUniqueArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobTitle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobTitleFindUniqueOrThrowArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobTitleFindUniqueOrThrowArgs>(args: SelectSubset<T, JobTitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindFirstArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobTitleFindFirstArgs>(args?: SelectSubset<T, JobTitleFindFirstArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobTitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindFirstOrThrowArgs} args - Arguments to find a JobTitle
     * @example
     * // Get one JobTitle
     * const jobTitle = await prisma.jobTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobTitleFindFirstOrThrowArgs>(args?: SelectSubset<T, JobTitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobTitles
     * const jobTitles = await prisma.jobTitle.findMany()
     * 
     * // Get first 10 JobTitles
     * const jobTitles = await prisma.jobTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobTitleWithIdOnly = await prisma.jobTitle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobTitleFindManyArgs>(args?: SelectSubset<T, JobTitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobTitle.
     * @param {JobTitleCreateArgs} args - Arguments to create a JobTitle.
     * @example
     * // Create one JobTitle
     * const JobTitle = await prisma.jobTitle.create({
     *   data: {
     *     // ... data to create a JobTitle
     *   }
     * })
     * 
     */
    create<T extends JobTitleCreateArgs>(args: SelectSubset<T, JobTitleCreateArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobTitles.
     * @param {JobTitleCreateManyArgs} args - Arguments to create many JobTitles.
     * @example
     * // Create many JobTitles
     * const jobTitle = await prisma.jobTitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobTitleCreateManyArgs>(args?: SelectSubset<T, JobTitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobTitles and returns the data saved in the database.
     * @param {JobTitleCreateManyAndReturnArgs} args - Arguments to create many JobTitles.
     * @example
     * // Create many JobTitles
     * const jobTitle = await prisma.jobTitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobTitles and only return the `id`
     * const jobTitleWithIdOnly = await prisma.jobTitle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobTitleCreateManyAndReturnArgs>(args?: SelectSubset<T, JobTitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobTitle.
     * @param {JobTitleDeleteArgs} args - Arguments to delete one JobTitle.
     * @example
     * // Delete one JobTitle
     * const JobTitle = await prisma.jobTitle.delete({
     *   where: {
     *     // ... filter to delete one JobTitle
     *   }
     * })
     * 
     */
    delete<T extends JobTitleDeleteArgs>(args: SelectSubset<T, JobTitleDeleteArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobTitle.
     * @param {JobTitleUpdateArgs} args - Arguments to update one JobTitle.
     * @example
     * // Update one JobTitle
     * const jobTitle = await prisma.jobTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobTitleUpdateArgs>(args: SelectSubset<T, JobTitleUpdateArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobTitles.
     * @param {JobTitleDeleteManyArgs} args - Arguments to filter JobTitles to delete.
     * @example
     * // Delete a few JobTitles
     * const { count } = await prisma.jobTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobTitleDeleteManyArgs>(args?: SelectSubset<T, JobTitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobTitles
     * const jobTitle = await prisma.jobTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobTitleUpdateManyArgs>(args: SelectSubset<T, JobTitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobTitle.
     * @param {JobTitleUpsertArgs} args - Arguments to update or create a JobTitle.
     * @example
     * // Update or create a JobTitle
     * const jobTitle = await prisma.jobTitle.upsert({
     *   create: {
     *     // ... data to create a JobTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobTitle we want to update
     *   }
     * })
     */
    upsert<T extends JobTitleUpsertArgs>(args: SelectSubset<T, JobTitleUpsertArgs<ExtArgs>>): Prisma__JobTitleClient<$Result.GetResult<Prisma.$JobTitlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleCountArgs} args - Arguments to filter JobTitles to count.
     * @example
     * // Count the number of JobTitles
     * const count = await prisma.jobTitle.count({
     *   where: {
     *     // ... the filter for the JobTitles we want to count
     *   }
     * })
    **/
    count<T extends JobTitleCountArgs>(
      args?: Subset<T, JobTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobTitleAggregateArgs>(args: Subset<T, JobTitleAggregateArgs>): Prisma.PrismaPromise<GetJobTitleAggregateType<T>>

    /**
     * Group by JobTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobTitleGroupByArgs['orderBy'] }
        : { orderBy?: JobTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobTitle model
   */
  readonly fields: JobTitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobTitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends JobTitle$companyArgs<ExtArgs> = {}>(args?: Subset<T, JobTitle$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobTitle model
   */ 
  interface JobTitleFieldRefs {
    readonly id: FieldRef<"JobTitle", 'String'>
    readonly name: FieldRef<"JobTitle", 'String'>
    readonly description: FieldRef<"JobTitle", 'String'>
    readonly createdAt: FieldRef<"JobTitle", 'DateTime'>
    readonly updatedAt: FieldRef<"JobTitle", 'DateTime'>
    readonly companyId: FieldRef<"JobTitle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobTitle findUnique
   */
  export type JobTitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle findUniqueOrThrow
   */
  export type JobTitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle findFirst
   */
  export type JobTitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle findFirstOrThrow
   */
  export type JobTitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter, which JobTitle to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobTitles.
     */
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle findMany
   */
  export type JobTitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter, which JobTitles to fetch.
     */
    where?: JobTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobTitles to fetch.
     */
    orderBy?: JobTitleOrderByWithRelationInput | JobTitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobTitles.
     */
    cursor?: JobTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobTitles.
     */
    skip?: number
    distinct?: JobTitleScalarFieldEnum | JobTitleScalarFieldEnum[]
  }

  /**
   * JobTitle create
   */
  export type JobTitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * The data needed to create a JobTitle.
     */
    data: XOR<JobTitleCreateInput, JobTitleUncheckedCreateInput>
  }

  /**
   * JobTitle createMany
   */
  export type JobTitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobTitles.
     */
    data: JobTitleCreateManyInput | JobTitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobTitle createManyAndReturn
   */
  export type JobTitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobTitles.
     */
    data: JobTitleCreateManyInput | JobTitleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobTitle update
   */
  export type JobTitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * The data needed to update a JobTitle.
     */
    data: XOR<JobTitleUpdateInput, JobTitleUncheckedUpdateInput>
    /**
     * Choose, which JobTitle to update.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle updateMany
   */
  export type JobTitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobTitles.
     */
    data: XOR<JobTitleUpdateManyMutationInput, JobTitleUncheckedUpdateManyInput>
    /**
     * Filter which JobTitles to update
     */
    where?: JobTitleWhereInput
  }

  /**
   * JobTitle upsert
   */
  export type JobTitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * The filter to search for the JobTitle to update in case it exists.
     */
    where: JobTitleWhereUniqueInput
    /**
     * In case the JobTitle found by the `where` argument doesn't exist, create a new JobTitle with this data.
     */
    create: XOR<JobTitleCreateInput, JobTitleUncheckedCreateInput>
    /**
     * In case the JobTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobTitleUpdateInput, JobTitleUncheckedUpdateInput>
  }

  /**
   * JobTitle delete
   */
  export type JobTitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
    /**
     * Filter which JobTitle to delete.
     */
    where: JobTitleWhereUniqueInput
  }

  /**
   * JobTitle deleteMany
   */
  export type JobTitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobTitles to delete
     */
    where?: JobTitleWhereInput
  }

  /**
   * JobTitle.company
   */
  export type JobTitle$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * JobTitle without action
   */
  export type JobTitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobTitle
     */
    select?: JobTitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobTitleInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    netAmount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    netAmount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    type: string | null
    emissionType: string | null
    purchaseOrderNumber: string | null
    dispatchGuideNumber: string | null
    netAmount: number | null
    taxAmount: number | null
    totalAmount: number | null
    clientId: string | null
    projectId: string | null
    costCenterId: string | null
    relatedInvoiceId: string | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    type: string | null
    emissionType: string | null
    purchaseOrderNumber: string | null
    dispatchGuideNumber: string | null
    netAmount: number | null
    taxAmount: number | null
    totalAmount: number | null
    clientId: string | null
    projectId: string | null
    costCenterId: string | null
    relatedInvoiceId: string | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    date: number
    dueDate: number
    status: number
    type: number
    emissionType: number
    purchaseOrderNumber: number
    dispatchGuideNumber: number
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId: number
    projectId: number
    costCenterId: number
    relatedInvoiceId: number
    isPaid: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    netAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    netAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    dueDate?: true
    status?: true
    type?: true
    emissionType?: true
    purchaseOrderNumber?: true
    dispatchGuideNumber?: true
    netAmount?: true
    taxAmount?: true
    totalAmount?: true
    clientId?: true
    projectId?: true
    costCenterId?: true
    relatedInvoiceId?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    dueDate?: true
    status?: true
    type?: true
    emissionType?: true
    purchaseOrderNumber?: true
    dispatchGuideNumber?: true
    netAmount?: true
    taxAmount?: true
    totalAmount?: true
    clientId?: true
    projectId?: true
    costCenterId?: true
    relatedInvoiceId?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    dueDate?: true
    status?: true
    type?: true
    emissionType?: true
    purchaseOrderNumber?: true
    dispatchGuideNumber?: true
    netAmount?: true
    taxAmount?: true
    totalAmount?: true
    clientId?: true
    projectId?: true
    costCenterId?: true
    relatedInvoiceId?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    date: Date
    dueDate: Date | null
    status: string
    type: string
    emissionType: string
    purchaseOrderNumber: string | null
    dispatchGuideNumber: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId: string | null
    projectId: string | null
    costCenterId: string | null
    relatedInvoiceId: string | null
    isPaid: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    type?: boolean
    emissionType?: boolean
    purchaseOrderNumber?: boolean
    dispatchGuideNumber?: boolean
    netAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    clientId?: boolean
    projectId?: boolean
    costCenterId?: boolean
    relatedInvoiceId?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | Invoice$clientArgs<ExtArgs>
    project?: boolean | Invoice$projectArgs<ExtArgs>
    costCenter?: boolean | Invoice$costCenterArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    relatedInvoice?: boolean | Invoice$relatedInvoiceArgs<ExtArgs>
    relatedByInvoices?: boolean | Invoice$relatedByInvoicesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    type?: boolean
    emissionType?: boolean
    purchaseOrderNumber?: boolean
    dispatchGuideNumber?: boolean
    netAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    clientId?: boolean
    projectId?: boolean
    costCenterId?: boolean
    relatedInvoiceId?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | Invoice$clientArgs<ExtArgs>
    project?: boolean | Invoice$projectArgs<ExtArgs>
    costCenter?: boolean | Invoice$costCenterArgs<ExtArgs>
    relatedInvoice?: boolean | Invoice$relatedInvoiceArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    type?: boolean
    emissionType?: boolean
    purchaseOrderNumber?: boolean
    dispatchGuideNumber?: boolean
    netAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    clientId?: boolean
    projectId?: boolean
    costCenterId?: boolean
    relatedInvoiceId?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Invoice$clientArgs<ExtArgs>
    project?: boolean | Invoice$projectArgs<ExtArgs>
    costCenter?: boolean | Invoice$costCenterArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    relatedInvoice?: boolean | Invoice$relatedInvoiceArgs<ExtArgs>
    relatedByInvoices?: boolean | Invoice$relatedByInvoicesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Invoice$clientArgs<ExtArgs>
    project?: boolean | Invoice$projectArgs<ExtArgs>
    costCenter?: boolean | Invoice$costCenterArgs<ExtArgs>
    relatedInvoice?: boolean | Invoice$relatedInvoiceArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      costCenter: Prisma.$CostCenterPayload<ExtArgs> | null
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      relatedInvoice: Prisma.$InvoicePayload<ExtArgs> | null
      relatedByInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      date: Date
      dueDate: Date | null
      status: string
      type: string
      emissionType: string
      purchaseOrderNumber: string | null
      dispatchGuideNumber: string | null
      netAmount: number
      taxAmount: number
      totalAmount: number
      clientId: string | null
      projectId: string | null
      costCenterId: string | null
      relatedInvoiceId: string | null
      isPaid: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Invoice$clientArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends Invoice$projectArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    costCenter<T extends Invoice$costCenterArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$costCenterArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    relatedInvoice<T extends Invoice$relatedInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$relatedInvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    relatedByInvoices<T extends Invoice$relatedByInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$relatedByInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'String'>
    readonly emissionType: FieldRef<"Invoice", 'String'>
    readonly purchaseOrderNumber: FieldRef<"Invoice", 'String'>
    readonly dispatchGuideNumber: FieldRef<"Invoice", 'String'>
    readonly netAmount: FieldRef<"Invoice", 'Float'>
    readonly taxAmount: FieldRef<"Invoice", 'Float'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly projectId: FieldRef<"Invoice", 'String'>
    readonly costCenterId: FieldRef<"Invoice", 'String'>
    readonly relatedInvoiceId: FieldRef<"Invoice", 'String'>
    readonly isPaid: FieldRef<"Invoice", 'Boolean'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly companyId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.client
   */
  export type Invoice$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Invoice.project
   */
  export type Invoice$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Invoice.costCenter
   */
  export type Invoice$costCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    where?: CostCenterWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.relatedInvoice
   */
  export type Invoice$relatedInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.relatedByInvoices
   */
  export type Invoice$relatedByInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    invoiceId: string | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    invoiceId: string | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unitPrice: number
    total: number
    invoiceId: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    invoiceId?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    invoiceId?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    invoiceId?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    invoiceId: string
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoiceId?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoiceId?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoiceId?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unitPrice: number
      total: number
      invoiceId: string
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Float'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Float'>
    readonly total: FieldRef<"InvoiceItem", 'Float'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model DailyReport
   */

  export type AggregateDailyReport = {
    _count: DailyReportCountAggregateOutputType | null
    _min: DailyReportMinAggregateOutputType | null
    _max: DailyReportMaxAggregateOutputType | null
  }

  export type DailyReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    content: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DailyReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    content: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DailyReportCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    content: number
    projectId: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type DailyReportMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    content?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DailyReportMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    content?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DailyReportCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    content?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type DailyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyReport to aggregate.
     */
    where?: DailyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReports to fetch.
     */
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyReports
    **/
    _count?: true | DailyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyReportMaxAggregateInputType
  }

  export type GetDailyReportAggregateType<T extends DailyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReport[P]>
      : GetScalarType<T[P], AggregateDailyReport[P]>
  }




  export type DailyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReportWhereInput
    orderBy?: DailyReportOrderByWithAggregationInput | DailyReportOrderByWithAggregationInput[]
    by: DailyReportScalarFieldEnum[] | DailyReportScalarFieldEnum
    having?: DailyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyReportCountAggregateInputType | true
    _min?: DailyReportMinAggregateInputType
    _max?: DailyReportMaxAggregateInputType
  }

  export type DailyReportGroupByOutputType = {
    id: string
    userId: string
    date: Date
    content: string
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: DailyReportCountAggregateOutputType | null
    _min: DailyReportMinAggregateOutputType | null
    _max: DailyReportMaxAggregateOutputType | null
  }

  type GetDailyReportGroupByPayload<T extends DailyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyReportGroupByOutputType[P]>
            : GetScalarType<T[P], DailyReportGroupByOutputType[P]>
        }
      >
    >


  export type DailyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    content?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | DailyReport$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReport"]>

  export type DailyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    content?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | DailyReport$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReport"]>

  export type DailyReportSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    content?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type DailyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | DailyReport$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DailyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | DailyReport$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DailyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      content: string
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["dailyReport"]>
    composites: {}
  }

  type DailyReportGetPayload<S extends boolean | null | undefined | DailyReportDefaultArgs> = $Result.GetResult<Prisma.$DailyReportPayload, S>

  type DailyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyReportCountAggregateInputType | true
    }

  export interface DailyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyReport'], meta: { name: 'DailyReport' } }
    /**
     * Find zero or one DailyReport that matches the filter.
     * @param {DailyReportFindUniqueArgs} args - Arguments to find a DailyReport
     * @example
     * // Get one DailyReport
     * const dailyReport = await prisma.dailyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyReportFindUniqueArgs>(args: SelectSubset<T, DailyReportFindUniqueArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyReportFindUniqueOrThrowArgs} args - Arguments to find a DailyReport
     * @example
     * // Get one DailyReport
     * const dailyReport = await prisma.dailyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportFindFirstArgs} args - Arguments to find a DailyReport
     * @example
     * // Get one DailyReport
     * const dailyReport = await prisma.dailyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyReportFindFirstArgs>(args?: SelectSubset<T, DailyReportFindFirstArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportFindFirstOrThrowArgs} args - Arguments to find a DailyReport
     * @example
     * // Get one DailyReport
     * const dailyReport = await prisma.dailyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyReports
     * const dailyReports = await prisma.dailyReport.findMany()
     * 
     * // Get first 10 DailyReports
     * const dailyReports = await prisma.dailyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyReportWithIdOnly = await prisma.dailyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyReportFindManyArgs>(args?: SelectSubset<T, DailyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyReport.
     * @param {DailyReportCreateArgs} args - Arguments to create a DailyReport.
     * @example
     * // Create one DailyReport
     * const DailyReport = await prisma.dailyReport.create({
     *   data: {
     *     // ... data to create a DailyReport
     *   }
     * })
     * 
     */
    create<T extends DailyReportCreateArgs>(args: SelectSubset<T, DailyReportCreateArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyReports.
     * @param {DailyReportCreateManyArgs} args - Arguments to create many DailyReports.
     * @example
     * // Create many DailyReports
     * const dailyReport = await prisma.dailyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyReportCreateManyArgs>(args?: SelectSubset<T, DailyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyReports and returns the data saved in the database.
     * @param {DailyReportCreateManyAndReturnArgs} args - Arguments to create many DailyReports.
     * @example
     * // Create many DailyReports
     * const dailyReport = await prisma.dailyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyReports and only return the `id`
     * const dailyReportWithIdOnly = await prisma.dailyReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyReport.
     * @param {DailyReportDeleteArgs} args - Arguments to delete one DailyReport.
     * @example
     * // Delete one DailyReport
     * const DailyReport = await prisma.dailyReport.delete({
     *   where: {
     *     // ... filter to delete one DailyReport
     *   }
     * })
     * 
     */
    delete<T extends DailyReportDeleteArgs>(args: SelectSubset<T, DailyReportDeleteArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyReport.
     * @param {DailyReportUpdateArgs} args - Arguments to update one DailyReport.
     * @example
     * // Update one DailyReport
     * const dailyReport = await prisma.dailyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyReportUpdateArgs>(args: SelectSubset<T, DailyReportUpdateArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyReports.
     * @param {DailyReportDeleteManyArgs} args - Arguments to filter DailyReports to delete.
     * @example
     * // Delete a few DailyReports
     * const { count } = await prisma.dailyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyReportDeleteManyArgs>(args?: SelectSubset<T, DailyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyReports
     * const dailyReport = await prisma.dailyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyReportUpdateManyArgs>(args: SelectSubset<T, DailyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyReport.
     * @param {DailyReportUpsertArgs} args - Arguments to update or create a DailyReport.
     * @example
     * // Update or create a DailyReport
     * const dailyReport = await prisma.dailyReport.upsert({
     *   create: {
     *     // ... data to create a DailyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReport we want to update
     *   }
     * })
     */
    upsert<T extends DailyReportUpsertArgs>(args: SelectSubset<T, DailyReportUpsertArgs<ExtArgs>>): Prisma__DailyReportClient<$Result.GetResult<Prisma.$DailyReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportCountArgs} args - Arguments to filter DailyReports to count.
     * @example
     * // Count the number of DailyReports
     * const count = await prisma.dailyReport.count({
     *   where: {
     *     // ... the filter for the DailyReports we want to count
     *   }
     * })
    **/
    count<T extends DailyReportCountArgs>(
      args?: Subset<T, DailyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyReportAggregateArgs>(args: Subset<T, DailyReportAggregateArgs>): Prisma.PrismaPromise<GetDailyReportAggregateType<T>>

    /**
     * Group by DailyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyReportGroupByArgs['orderBy'] }
        : { orderBy?: DailyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyReport model
   */
  readonly fields: DailyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends DailyReport$projectArgs<ExtArgs> = {}>(args?: Subset<T, DailyReport$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyReport model
   */ 
  interface DailyReportFieldRefs {
    readonly id: FieldRef<"DailyReport", 'String'>
    readonly userId: FieldRef<"DailyReport", 'String'>
    readonly date: FieldRef<"DailyReport", 'DateTime'>
    readonly content: FieldRef<"DailyReport", 'String'>
    readonly projectId: FieldRef<"DailyReport", 'String'>
    readonly createdAt: FieldRef<"DailyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyReport", 'DateTime'>
    readonly companyId: FieldRef<"DailyReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyReport findUnique
   */
  export type DailyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter, which DailyReport to fetch.
     */
    where: DailyReportWhereUniqueInput
  }

  /**
   * DailyReport findUniqueOrThrow
   */
  export type DailyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter, which DailyReport to fetch.
     */
    where: DailyReportWhereUniqueInput
  }

  /**
   * DailyReport findFirst
   */
  export type DailyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter, which DailyReport to fetch.
     */
    where?: DailyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReports to fetch.
     */
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyReports.
     */
    cursor?: DailyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyReports.
     */
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * DailyReport findFirstOrThrow
   */
  export type DailyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter, which DailyReport to fetch.
     */
    where?: DailyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReports to fetch.
     */
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyReports.
     */
    cursor?: DailyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyReports.
     */
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * DailyReport findMany
   */
  export type DailyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter, which DailyReports to fetch.
     */
    where?: DailyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReports to fetch.
     */
    orderBy?: DailyReportOrderByWithRelationInput | DailyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyReports.
     */
    cursor?: DailyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReports.
     */
    skip?: number
    distinct?: DailyReportScalarFieldEnum | DailyReportScalarFieldEnum[]
  }

  /**
   * DailyReport create
   */
  export type DailyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyReport.
     */
    data: XOR<DailyReportCreateInput, DailyReportUncheckedCreateInput>
  }

  /**
   * DailyReport createMany
   */
  export type DailyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyReports.
     */
    data: DailyReportCreateManyInput | DailyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyReport createManyAndReturn
   */
  export type DailyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyReports.
     */
    data: DailyReportCreateManyInput | DailyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyReport update
   */
  export type DailyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyReport.
     */
    data: XOR<DailyReportUpdateInput, DailyReportUncheckedUpdateInput>
    /**
     * Choose, which DailyReport to update.
     */
    where: DailyReportWhereUniqueInput
  }

  /**
   * DailyReport updateMany
   */
  export type DailyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyReports.
     */
    data: XOR<DailyReportUpdateManyMutationInput, DailyReportUncheckedUpdateManyInput>
    /**
     * Filter which DailyReports to update
     */
    where?: DailyReportWhereInput
  }

  /**
   * DailyReport upsert
   */
  export type DailyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyReport to update in case it exists.
     */
    where: DailyReportWhereUniqueInput
    /**
     * In case the DailyReport found by the `where` argument doesn't exist, create a new DailyReport with this data.
     */
    create: XOR<DailyReportCreateInput, DailyReportUncheckedCreateInput>
    /**
     * In case the DailyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyReportUpdateInput, DailyReportUncheckedUpdateInput>
  }

  /**
   * DailyReport delete
   */
  export type DailyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
    /**
     * Filter which DailyReport to delete.
     */
    where: DailyReportWhereUniqueInput
  }

  /**
   * DailyReport deleteMany
   */
  export type DailyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyReports to delete
     */
    where?: DailyReportWhereInput
  }

  /**
   * DailyReport.project
   */
  export type DailyReport$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * DailyReport without action
   */
  export type DailyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReport
     */
    select?: DailyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReportInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    number: string | null
    provider: string | null
    date: Date | null
    status: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    number: string | null
    provider: string | null
    date: Date | null
    status: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    number: number
    provider: number
    date: number
    status: number
    projectId: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    number?: true
    provider?: true
    date?: true
    status?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    number?: true
    provider?: true
    date?: true
    status?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    number?: true
    provider?: true
    date?: true
    status?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    number: string
    provider: string
    date: Date
    status: string
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    provider?: boolean
    date?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | PurchaseOrder$projectArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    provider?: boolean
    date?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | PurchaseOrder$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    number?: boolean
    provider?: boolean
    date?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PurchaseOrder$projectArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PurchaseOrder$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      provider: string
      date: Date
      status: string
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends PurchaseOrder$projectArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly number: FieldRef<"PurchaseOrder", 'String'>
    readonly provider: FieldRef<"PurchaseOrder", 'String'>
    readonly date: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly projectId: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly companyId: FieldRef<"PurchaseOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder.project
   */
  export type PurchaseOrder$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    purchaseOrderId: string | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    purchaseOrderId: string | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unitPrice: number
    total: number
    purchaseOrderId: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    purchaseOrderId?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    purchaseOrderId?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    purchaseOrderId?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    purchaseOrderId: string
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    purchaseOrderId?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    purchaseOrderId?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    purchaseOrderId?: boolean
  }

  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unitPrice: number
      total: number
      purchaseOrderId: string
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */ 
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly description: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly unitPrice: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly total: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    projectId: string | null
    clientId: string | null
    createdAt: Date | null
    requirementId: string | null
    status: string | null
    companyId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    projectId: string | null
    clientId: string | null
    createdAt: Date | null
    requirementId: string | null
    status: string | null
    companyId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    url: number
    type: number
    projectId: number
    clientId: number
    createdAt: number
    requirementId: number
    status: number
    companyId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    projectId?: true
    clientId?: true
    createdAt?: true
    requirementId?: true
    status?: true
    companyId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    projectId?: true
    clientId?: true
    createdAt?: true
    requirementId?: true
    status?: true
    companyId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    projectId?: true
    clientId?: true
    createdAt?: true
    requirementId?: true
    status?: true
    companyId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    url: string
    type: string
    projectId: string | null
    clientId: string | null
    createdAt: Date
    requirementId: string | null
    status: string
    companyId: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    projectId?: boolean
    clientId?: boolean
    createdAt?: boolean
    requirementId?: boolean
    status?: boolean
    companyId?: boolean
    project?: boolean | Document$projectArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    projectId?: boolean
    clientId?: boolean
    createdAt?: boolean
    requirementId?: boolean
    status?: boolean
    companyId?: boolean
    project?: boolean | Document$projectArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    projectId?: boolean
    clientId?: boolean
    createdAt?: boolean
    requirementId?: boolean
    status?: boolean
    companyId?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Document$projectArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Document$projectArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    requirement?: boolean | Document$requirementArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      requirement: Prisma.$DocumentRequirementPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      type: string
      projectId: string | null
      clientId: string | null
      createdAt: Date
      requirementId: string | null
      status: string
      companyId: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Document$projectArgs<ExtArgs> = {}>(args?: Subset<T, Document$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Document$clientArgs<ExtArgs> = {}>(args?: Subset<T, Document$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requirement<T extends Document$requirementArgs<ExtArgs> = {}>(args?: Subset<T, Document$requirementArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly projectId: FieldRef<"Document", 'String'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly requirementId: FieldRef<"Document", 'String'>
    readonly status: FieldRef<"Document", 'String'>
    readonly companyId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.project
   */
  export type Document$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Document.client
   */
  export type Document$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Document.requirement
   */
  export type Document$requirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    where?: DocumentRequirementWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentRequirement
   */

  export type AggregateDocumentRequirement = {
    _count: DocumentRequirementCountAggregateOutputType | null
    _avg: DocumentRequirementAvgAggregateOutputType | null
    _sum: DocumentRequirementSumAggregateOutputType | null
    _min: DocumentRequirementMinAggregateOutputType | null
    _max: DocumentRequirementMaxAggregateOutputType | null
  }

  export type DocumentRequirementAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type DocumentRequirementSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type DocumentRequirementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    month: number | null
    year: number | null
    status: string | null
    dueDate: Date | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DocumentRequirementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    month: number | null
    year: number | null
    status: string | null
    dueDate: Date | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DocumentRequirementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    month: number
    year: number
    status: number
    dueDate: number
    clientId: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type DocumentRequirementAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type DocumentRequirementSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type DocumentRequirementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    month?: true
    year?: true
    status?: true
    dueDate?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DocumentRequirementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    month?: true
    year?: true
    status?: true
    dueDate?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DocumentRequirementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    month?: true
    year?: true
    status?: true
    dueDate?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type DocumentRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRequirement to aggregate.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentRequirements
    **/
    _count?: true | DocumentRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentRequirementMaxAggregateInputType
  }

  export type GetDocumentRequirementAggregateType<T extends DocumentRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentRequirement[P]>
      : GetScalarType<T[P], AggregateDocumentRequirement[P]>
  }




  export type DocumentRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRequirementWhereInput
    orderBy?: DocumentRequirementOrderByWithAggregationInput | DocumentRequirementOrderByWithAggregationInput[]
    by: DocumentRequirementScalarFieldEnum[] | DocumentRequirementScalarFieldEnum
    having?: DocumentRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentRequirementCountAggregateInputType | true
    _avg?: DocumentRequirementAvgAggregateInputType
    _sum?: DocumentRequirementSumAggregateInputType
    _min?: DocumentRequirementMinAggregateInputType
    _max?: DocumentRequirementMaxAggregateInputType
  }

  export type DocumentRequirementGroupByOutputType = {
    id: string
    name: string
    description: string | null
    month: number | null
    year: number | null
    status: string
    dueDate: Date | null
    clientId: string
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: DocumentRequirementCountAggregateOutputType | null
    _avg: DocumentRequirementAvgAggregateOutputType | null
    _sum: DocumentRequirementSumAggregateOutputType | null
    _min: DocumentRequirementMinAggregateOutputType | null
    _max: DocumentRequirementMaxAggregateOutputType | null
  }

  type GetDocumentRequirementGroupByPayload<T extends DocumentRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentRequirementGroupByOutputType[P]>
        }
      >
    >


  export type DocumentRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    month?: boolean
    year?: boolean
    status?: boolean
    dueDate?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    documents?: boolean | DocumentRequirement$documentsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRequirement"]>

  export type DocumentRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    month?: boolean
    year?: boolean
    status?: boolean
    dueDate?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRequirement"]>

  export type DocumentRequirementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    month?: boolean
    year?: boolean
    status?: boolean
    dueDate?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type DocumentRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    documents?: boolean | DocumentRequirement$documentsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | DocumentRequirementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DocumentRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentRequirement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      month: number | null
      year: number | null
      status: string
      dueDate: Date | null
      clientId: string
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["documentRequirement"]>
    composites: {}
  }

  type DocumentRequirementGetPayload<S extends boolean | null | undefined | DocumentRequirementDefaultArgs> = $Result.GetResult<Prisma.$DocumentRequirementPayload, S>

  type DocumentRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentRequirementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentRequirementCountAggregateInputType | true
    }

  export interface DocumentRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentRequirement'], meta: { name: 'DocumentRequirement' } }
    /**
     * Find zero or one DocumentRequirement that matches the filter.
     * @param {DocumentRequirementFindUniqueArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentRequirementFindUniqueArgs>(args: SelectSubset<T, DocumentRequirementFindUniqueArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentRequirement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentRequirementFindUniqueOrThrowArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindFirstArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentRequirementFindFirstArgs>(args?: SelectSubset<T, DocumentRequirementFindFirstArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindFirstOrThrowArgs} args - Arguments to find a DocumentRequirement
     * @example
     * // Get one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentRequirements
     * const documentRequirements = await prisma.documentRequirement.findMany()
     * 
     * // Get first 10 DocumentRequirements
     * const documentRequirements = await prisma.documentRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentRequirementWithIdOnly = await prisma.documentRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentRequirementFindManyArgs>(args?: SelectSubset<T, DocumentRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentRequirement.
     * @param {DocumentRequirementCreateArgs} args - Arguments to create a DocumentRequirement.
     * @example
     * // Create one DocumentRequirement
     * const DocumentRequirement = await prisma.documentRequirement.create({
     *   data: {
     *     // ... data to create a DocumentRequirement
     *   }
     * })
     * 
     */
    create<T extends DocumentRequirementCreateArgs>(args: SelectSubset<T, DocumentRequirementCreateArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentRequirements.
     * @param {DocumentRequirementCreateManyArgs} args - Arguments to create many DocumentRequirements.
     * @example
     * // Create many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentRequirementCreateManyArgs>(args?: SelectSubset<T, DocumentRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentRequirements and returns the data saved in the database.
     * @param {DocumentRequirementCreateManyAndReturnArgs} args - Arguments to create many DocumentRequirements.
     * @example
     * // Create many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentRequirements and only return the `id`
     * const documentRequirementWithIdOnly = await prisma.documentRequirement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentRequirement.
     * @param {DocumentRequirementDeleteArgs} args - Arguments to delete one DocumentRequirement.
     * @example
     * // Delete one DocumentRequirement
     * const DocumentRequirement = await prisma.documentRequirement.delete({
     *   where: {
     *     // ... filter to delete one DocumentRequirement
     *   }
     * })
     * 
     */
    delete<T extends DocumentRequirementDeleteArgs>(args: SelectSubset<T, DocumentRequirementDeleteArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentRequirement.
     * @param {DocumentRequirementUpdateArgs} args - Arguments to update one DocumentRequirement.
     * @example
     * // Update one DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentRequirementUpdateArgs>(args: SelectSubset<T, DocumentRequirementUpdateArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentRequirements.
     * @param {DocumentRequirementDeleteManyArgs} args - Arguments to filter DocumentRequirements to delete.
     * @example
     * // Delete a few DocumentRequirements
     * const { count } = await prisma.documentRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentRequirementDeleteManyArgs>(args?: SelectSubset<T, DocumentRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentRequirements
     * const documentRequirement = await prisma.documentRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentRequirementUpdateManyArgs>(args: SelectSubset<T, DocumentRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentRequirement.
     * @param {DocumentRequirementUpsertArgs} args - Arguments to update or create a DocumentRequirement.
     * @example
     * // Update or create a DocumentRequirement
     * const documentRequirement = await prisma.documentRequirement.upsert({
     *   create: {
     *     // ... data to create a DocumentRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentRequirement we want to update
     *   }
     * })
     */
    upsert<T extends DocumentRequirementUpsertArgs>(args: SelectSubset<T, DocumentRequirementUpsertArgs<ExtArgs>>): Prisma__DocumentRequirementClient<$Result.GetResult<Prisma.$DocumentRequirementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementCountArgs} args - Arguments to filter DocumentRequirements to count.
     * @example
     * // Count the number of DocumentRequirements
     * const count = await prisma.documentRequirement.count({
     *   where: {
     *     // ... the filter for the DocumentRequirements we want to count
     *   }
     * })
    **/
    count<T extends DocumentRequirementCountArgs>(
      args?: Subset<T, DocumentRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentRequirementAggregateArgs>(args: Subset<T, DocumentRequirementAggregateArgs>): Prisma.PrismaPromise<GetDocumentRequirementAggregateType<T>>

    /**
     * Group by DocumentRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentRequirementGroupByArgs['orderBy'] }
        : { orderBy?: DocumentRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentRequirement model
   */
  readonly fields: DocumentRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends DocumentRequirement$documentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentRequirement$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentRequirement model
   */ 
  interface DocumentRequirementFieldRefs {
    readonly id: FieldRef<"DocumentRequirement", 'String'>
    readonly name: FieldRef<"DocumentRequirement", 'String'>
    readonly description: FieldRef<"DocumentRequirement", 'String'>
    readonly month: FieldRef<"DocumentRequirement", 'Int'>
    readonly year: FieldRef<"DocumentRequirement", 'Int'>
    readonly status: FieldRef<"DocumentRequirement", 'String'>
    readonly dueDate: FieldRef<"DocumentRequirement", 'DateTime'>
    readonly clientId: FieldRef<"DocumentRequirement", 'String'>
    readonly createdAt: FieldRef<"DocumentRequirement", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentRequirement", 'DateTime'>
    readonly companyId: FieldRef<"DocumentRequirement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentRequirement findUnique
   */
  export type DocumentRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement findUniqueOrThrow
   */
  export type DocumentRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement findFirst
   */
  export type DocumentRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRequirements.
     */
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement findFirstOrThrow
   */
  export type DocumentRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirement to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRequirements.
     */
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement findMany
   */
  export type DocumentRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRequirements to fetch.
     */
    where?: DocumentRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRequirements to fetch.
     */
    orderBy?: DocumentRequirementOrderByWithRelationInput | DocumentRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentRequirements.
     */
    cursor?: DocumentRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRequirements.
     */
    skip?: number
    distinct?: DocumentRequirementScalarFieldEnum | DocumentRequirementScalarFieldEnum[]
  }

  /**
   * DocumentRequirement create
   */
  export type DocumentRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentRequirement.
     */
    data: XOR<DocumentRequirementCreateInput, DocumentRequirementUncheckedCreateInput>
  }

  /**
   * DocumentRequirement createMany
   */
  export type DocumentRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentRequirements.
     */
    data: DocumentRequirementCreateManyInput | DocumentRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentRequirement createManyAndReturn
   */
  export type DocumentRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentRequirements.
     */
    data: DocumentRequirementCreateManyInput | DocumentRequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentRequirement update
   */
  export type DocumentRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentRequirement.
     */
    data: XOR<DocumentRequirementUpdateInput, DocumentRequirementUncheckedUpdateInput>
    /**
     * Choose, which DocumentRequirement to update.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement updateMany
   */
  export type DocumentRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentRequirements.
     */
    data: XOR<DocumentRequirementUpdateManyMutationInput, DocumentRequirementUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRequirements to update
     */
    where?: DocumentRequirementWhereInput
  }

  /**
   * DocumentRequirement upsert
   */
  export type DocumentRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentRequirement to update in case it exists.
     */
    where: DocumentRequirementWhereUniqueInput
    /**
     * In case the DocumentRequirement found by the `where` argument doesn't exist, create a new DocumentRequirement with this data.
     */
    create: XOR<DocumentRequirementCreateInput, DocumentRequirementUncheckedCreateInput>
    /**
     * In case the DocumentRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentRequirementUpdateInput, DocumentRequirementUncheckedUpdateInput>
  }

  /**
   * DocumentRequirement delete
   */
  export type DocumentRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
    /**
     * Filter which DocumentRequirement to delete.
     */
    where: DocumentRequirementWhereUniqueInput
  }

  /**
   * DocumentRequirement deleteMany
   */
  export type DocumentRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRequirements to delete
     */
    where?: DocumentRequirementWhereInput
  }

  /**
   * DocumentRequirement.documents
   */
  export type DocumentRequirement$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * DocumentRequirement without action
   */
  export type DocumentRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRequirement
     */
    select?: DocumentRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRequirementInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    minStock: number | null
    currentStock: number | null
    price: number | null
  }

  export type MaterialSumAggregateOutputType = {
    minStock: number | null
    currentStock: number | null
    price: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    unit: string | null
    minStock: number | null
    currentStock: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    unit: string | null
    minStock: number | null
    currentStock: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    code: number
    name: number
    unit: number
    minStock: number
    currentStock: number
    price: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    minStock?: true
    currentStock?: true
    price?: true
  }

  export type MaterialSumAggregateInputType = {
    minStock?: true
    currentStock?: true
    price?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    minStock?: true
    currentStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    minStock?: true
    currentStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    minStock?: true
    currentStock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    code: string | null
    name: string
    unit: string
    minStock: number
    currentStock: number
    price: number
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    minStock?: boolean
    currentStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    movements?: boolean | Material$movementsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    minStock?: boolean
    currentStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    minStock?: boolean
    currentStock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | Material$movementsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string | null
      name: string
      unit: string
      minStock: number
      currentStock: number
      price: number
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movements<T extends Material$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Material$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly code: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly minStock: FieldRef<"Material", 'Float'>
    readonly currentStock: FieldRef<"Material", 'Float'>
    readonly price: FieldRef<"Material", 'Float'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
    readonly companyId: FieldRef<"Material", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }

  /**
   * Material.movements
   */
  export type Material$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    type: string | null
    quantity: number | null
    date: Date | null
    description: string | null
    materialId: string | null
    projectId: string | null
    createdAt: Date | null
    companyId: string | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    type: string | null
    quantity: number | null
    date: Date | null
    description: string | null
    materialId: string | null
    projectId: string | null
    createdAt: Date | null
    companyId: string | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    type: number
    quantity: number
    date: number
    description: number
    materialId: number
    projectId: number
    createdAt: number
    companyId: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    description?: true
    materialId?: true
    projectId?: true
    createdAt?: true
    companyId?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    description?: true
    materialId?: true
    projectId?: true
    createdAt?: true
    companyId?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    description?: true
    materialId?: true
    projectId?: true
    createdAt?: true
    companyId?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    type: string
    quantity: number
    date: Date
    description: string | null
    materialId: string
    projectId: string | null
    createdAt: Date
    companyId: string
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    description?: boolean
    materialId?: boolean
    projectId?: boolean
    createdAt?: boolean
    companyId?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | InventoryMovement$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    description?: boolean
    materialId?: boolean
    projectId?: boolean
    createdAt?: boolean
    companyId?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | InventoryMovement$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    description?: boolean
    materialId?: boolean
    projectId?: boolean
    createdAt?: boolean
    companyId?: boolean
  }

  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | InventoryMovement$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    project?: boolean | InventoryMovement$projectArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      quantity: number
      date: Date
      description: string | null
      materialId: string
      projectId: string | null
      createdAt: Date
      companyId: string
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends InventoryMovement$projectArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */ 
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'String'>
    readonly quantity: FieldRef<"InventoryMovement", 'Float'>
    readonly date: FieldRef<"InventoryMovement", 'DateTime'>
    readonly description: FieldRef<"InventoryMovement", 'String'>
    readonly materialId: FieldRef<"InventoryMovement", 'String'>
    readonly projectId: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
    readonly companyId: FieldRef<"InventoryMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
  }

  /**
   * InventoryMovement.project
   */
  export type InventoryMovement$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model ClientMonthlyInfo
   */

  export type AggregateClientMonthlyInfo = {
    _count: ClientMonthlyInfoCountAggregateOutputType | null
    _avg: ClientMonthlyInfoAvgAggregateOutputType | null
    _sum: ClientMonthlyInfoSumAggregateOutputType | null
    _min: ClientMonthlyInfoMinAggregateOutputType | null
    _max: ClientMonthlyInfoMaxAggregateOutputType | null
  }

  export type ClientMonthlyInfoAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type ClientMonthlyInfoSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type ClientMonthlyInfoMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    month: number | null
    year: number | null
    edpDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ClientMonthlyInfoMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    month: number | null
    year: number | null
    edpDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ClientMonthlyInfoCountAggregateOutputType = {
    id: number
    clientId: number
    month: number
    year: number
    edpDate: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ClientMonthlyInfoAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type ClientMonthlyInfoSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type ClientMonthlyInfoMinAggregateInputType = {
    id?: true
    clientId?: true
    month?: true
    year?: true
    edpDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ClientMonthlyInfoMaxAggregateInputType = {
    id?: true
    clientId?: true
    month?: true
    year?: true
    edpDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ClientMonthlyInfoCountAggregateInputType = {
    id?: true
    clientId?: true
    month?: true
    year?: true
    edpDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ClientMonthlyInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientMonthlyInfo to aggregate.
     */
    where?: ClientMonthlyInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMonthlyInfos to fetch.
     */
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientMonthlyInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMonthlyInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMonthlyInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientMonthlyInfos
    **/
    _count?: true | ClientMonthlyInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientMonthlyInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientMonthlyInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMonthlyInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMonthlyInfoMaxAggregateInputType
  }

  export type GetClientMonthlyInfoAggregateType<T extends ClientMonthlyInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateClientMonthlyInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientMonthlyInfo[P]>
      : GetScalarType<T[P], AggregateClientMonthlyInfo[P]>
  }




  export type ClientMonthlyInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientMonthlyInfoWhereInput
    orderBy?: ClientMonthlyInfoOrderByWithAggregationInput | ClientMonthlyInfoOrderByWithAggregationInput[]
    by: ClientMonthlyInfoScalarFieldEnum[] | ClientMonthlyInfoScalarFieldEnum
    having?: ClientMonthlyInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientMonthlyInfoCountAggregateInputType | true
    _avg?: ClientMonthlyInfoAvgAggregateInputType
    _sum?: ClientMonthlyInfoSumAggregateInputType
    _min?: ClientMonthlyInfoMinAggregateInputType
    _max?: ClientMonthlyInfoMaxAggregateInputType
  }

  export type ClientMonthlyInfoGroupByOutputType = {
    id: string
    clientId: string
    month: number
    year: number
    edpDate: Date | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ClientMonthlyInfoCountAggregateOutputType | null
    _avg: ClientMonthlyInfoAvgAggregateOutputType | null
    _sum: ClientMonthlyInfoSumAggregateOutputType | null
    _min: ClientMonthlyInfoMinAggregateOutputType | null
    _max: ClientMonthlyInfoMaxAggregateOutputType | null
  }

  type GetClientMonthlyInfoGroupByPayload<T extends ClientMonthlyInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientMonthlyInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientMonthlyInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientMonthlyInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ClientMonthlyInfoGroupByOutputType[P]>
        }
      >
    >


  export type ClientMonthlyInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    month?: boolean
    year?: boolean
    edpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientMonthlyInfo"]>

  export type ClientMonthlyInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    month?: boolean
    year?: boolean
    edpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientMonthlyInfo"]>

  export type ClientMonthlyInfoSelectScalar = {
    id?: boolean
    clientId?: boolean
    month?: boolean
    year?: boolean
    edpDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ClientMonthlyInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ClientMonthlyInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ClientMonthlyInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientMonthlyInfo"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      month: number
      year: number
      edpDate: Date | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["clientMonthlyInfo"]>
    composites: {}
  }

  type ClientMonthlyInfoGetPayload<S extends boolean | null | undefined | ClientMonthlyInfoDefaultArgs> = $Result.GetResult<Prisma.$ClientMonthlyInfoPayload, S>

  type ClientMonthlyInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientMonthlyInfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientMonthlyInfoCountAggregateInputType | true
    }

  export interface ClientMonthlyInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientMonthlyInfo'], meta: { name: 'ClientMonthlyInfo' } }
    /**
     * Find zero or one ClientMonthlyInfo that matches the filter.
     * @param {ClientMonthlyInfoFindUniqueArgs} args - Arguments to find a ClientMonthlyInfo
     * @example
     * // Get one ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientMonthlyInfoFindUniqueArgs>(args: SelectSubset<T, ClientMonthlyInfoFindUniqueArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientMonthlyInfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientMonthlyInfoFindUniqueOrThrowArgs} args - Arguments to find a ClientMonthlyInfo
     * @example
     * // Get one ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientMonthlyInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientMonthlyInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientMonthlyInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoFindFirstArgs} args - Arguments to find a ClientMonthlyInfo
     * @example
     * // Get one ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientMonthlyInfoFindFirstArgs>(args?: SelectSubset<T, ClientMonthlyInfoFindFirstArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientMonthlyInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoFindFirstOrThrowArgs} args - Arguments to find a ClientMonthlyInfo
     * @example
     * // Get one ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientMonthlyInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientMonthlyInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientMonthlyInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientMonthlyInfos
     * const clientMonthlyInfos = await prisma.clientMonthlyInfo.findMany()
     * 
     * // Get first 10 ClientMonthlyInfos
     * const clientMonthlyInfos = await prisma.clientMonthlyInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientMonthlyInfoWithIdOnly = await prisma.clientMonthlyInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientMonthlyInfoFindManyArgs>(args?: SelectSubset<T, ClientMonthlyInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientMonthlyInfo.
     * @param {ClientMonthlyInfoCreateArgs} args - Arguments to create a ClientMonthlyInfo.
     * @example
     * // Create one ClientMonthlyInfo
     * const ClientMonthlyInfo = await prisma.clientMonthlyInfo.create({
     *   data: {
     *     // ... data to create a ClientMonthlyInfo
     *   }
     * })
     * 
     */
    create<T extends ClientMonthlyInfoCreateArgs>(args: SelectSubset<T, ClientMonthlyInfoCreateArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientMonthlyInfos.
     * @param {ClientMonthlyInfoCreateManyArgs} args - Arguments to create many ClientMonthlyInfos.
     * @example
     * // Create many ClientMonthlyInfos
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientMonthlyInfoCreateManyArgs>(args?: SelectSubset<T, ClientMonthlyInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientMonthlyInfos and returns the data saved in the database.
     * @param {ClientMonthlyInfoCreateManyAndReturnArgs} args - Arguments to create many ClientMonthlyInfos.
     * @example
     * // Create many ClientMonthlyInfos
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientMonthlyInfos and only return the `id`
     * const clientMonthlyInfoWithIdOnly = await prisma.clientMonthlyInfo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientMonthlyInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientMonthlyInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientMonthlyInfo.
     * @param {ClientMonthlyInfoDeleteArgs} args - Arguments to delete one ClientMonthlyInfo.
     * @example
     * // Delete one ClientMonthlyInfo
     * const ClientMonthlyInfo = await prisma.clientMonthlyInfo.delete({
     *   where: {
     *     // ... filter to delete one ClientMonthlyInfo
     *   }
     * })
     * 
     */
    delete<T extends ClientMonthlyInfoDeleteArgs>(args: SelectSubset<T, ClientMonthlyInfoDeleteArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientMonthlyInfo.
     * @param {ClientMonthlyInfoUpdateArgs} args - Arguments to update one ClientMonthlyInfo.
     * @example
     * // Update one ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientMonthlyInfoUpdateArgs>(args: SelectSubset<T, ClientMonthlyInfoUpdateArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientMonthlyInfos.
     * @param {ClientMonthlyInfoDeleteManyArgs} args - Arguments to filter ClientMonthlyInfos to delete.
     * @example
     * // Delete a few ClientMonthlyInfos
     * const { count } = await prisma.clientMonthlyInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientMonthlyInfoDeleteManyArgs>(args?: SelectSubset<T, ClientMonthlyInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientMonthlyInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientMonthlyInfos
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientMonthlyInfoUpdateManyArgs>(args: SelectSubset<T, ClientMonthlyInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientMonthlyInfo.
     * @param {ClientMonthlyInfoUpsertArgs} args - Arguments to update or create a ClientMonthlyInfo.
     * @example
     * // Update or create a ClientMonthlyInfo
     * const clientMonthlyInfo = await prisma.clientMonthlyInfo.upsert({
     *   create: {
     *     // ... data to create a ClientMonthlyInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientMonthlyInfo we want to update
     *   }
     * })
     */
    upsert<T extends ClientMonthlyInfoUpsertArgs>(args: SelectSubset<T, ClientMonthlyInfoUpsertArgs<ExtArgs>>): Prisma__ClientMonthlyInfoClient<$Result.GetResult<Prisma.$ClientMonthlyInfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientMonthlyInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoCountArgs} args - Arguments to filter ClientMonthlyInfos to count.
     * @example
     * // Count the number of ClientMonthlyInfos
     * const count = await prisma.clientMonthlyInfo.count({
     *   where: {
     *     // ... the filter for the ClientMonthlyInfos we want to count
     *   }
     * })
    **/
    count<T extends ClientMonthlyInfoCountArgs>(
      args?: Subset<T, ClientMonthlyInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientMonthlyInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientMonthlyInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientMonthlyInfoAggregateArgs>(args: Subset<T, ClientMonthlyInfoAggregateArgs>): Prisma.PrismaPromise<GetClientMonthlyInfoAggregateType<T>>

    /**
     * Group by ClientMonthlyInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMonthlyInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientMonthlyInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientMonthlyInfoGroupByArgs['orderBy'] }
        : { orderBy?: ClientMonthlyInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientMonthlyInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientMonthlyInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientMonthlyInfo model
   */
  readonly fields: ClientMonthlyInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientMonthlyInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientMonthlyInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientMonthlyInfo model
   */ 
  interface ClientMonthlyInfoFieldRefs {
    readonly id: FieldRef<"ClientMonthlyInfo", 'String'>
    readonly clientId: FieldRef<"ClientMonthlyInfo", 'String'>
    readonly month: FieldRef<"ClientMonthlyInfo", 'Int'>
    readonly year: FieldRef<"ClientMonthlyInfo", 'Int'>
    readonly edpDate: FieldRef<"ClientMonthlyInfo", 'DateTime'>
    readonly createdAt: FieldRef<"ClientMonthlyInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientMonthlyInfo", 'DateTime'>
    readonly companyId: FieldRef<"ClientMonthlyInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientMonthlyInfo findUnique
   */
  export type ClientMonthlyInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClientMonthlyInfo to fetch.
     */
    where: ClientMonthlyInfoWhereUniqueInput
  }

  /**
   * ClientMonthlyInfo findUniqueOrThrow
   */
  export type ClientMonthlyInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClientMonthlyInfo to fetch.
     */
    where: ClientMonthlyInfoWhereUniqueInput
  }

  /**
   * ClientMonthlyInfo findFirst
   */
  export type ClientMonthlyInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClientMonthlyInfo to fetch.
     */
    where?: ClientMonthlyInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMonthlyInfos to fetch.
     */
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientMonthlyInfos.
     */
    cursor?: ClientMonthlyInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMonthlyInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMonthlyInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientMonthlyInfos.
     */
    distinct?: ClientMonthlyInfoScalarFieldEnum | ClientMonthlyInfoScalarFieldEnum[]
  }

  /**
   * ClientMonthlyInfo findFirstOrThrow
   */
  export type ClientMonthlyInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClientMonthlyInfo to fetch.
     */
    where?: ClientMonthlyInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMonthlyInfos to fetch.
     */
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientMonthlyInfos.
     */
    cursor?: ClientMonthlyInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMonthlyInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMonthlyInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientMonthlyInfos.
     */
    distinct?: ClientMonthlyInfoScalarFieldEnum | ClientMonthlyInfoScalarFieldEnum[]
  }

  /**
   * ClientMonthlyInfo findMany
   */
  export type ClientMonthlyInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter, which ClientMonthlyInfos to fetch.
     */
    where?: ClientMonthlyInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMonthlyInfos to fetch.
     */
    orderBy?: ClientMonthlyInfoOrderByWithRelationInput | ClientMonthlyInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientMonthlyInfos.
     */
    cursor?: ClientMonthlyInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMonthlyInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMonthlyInfos.
     */
    skip?: number
    distinct?: ClientMonthlyInfoScalarFieldEnum | ClientMonthlyInfoScalarFieldEnum[]
  }

  /**
   * ClientMonthlyInfo create
   */
  export type ClientMonthlyInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientMonthlyInfo.
     */
    data: XOR<ClientMonthlyInfoCreateInput, ClientMonthlyInfoUncheckedCreateInput>
  }

  /**
   * ClientMonthlyInfo createMany
   */
  export type ClientMonthlyInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientMonthlyInfos.
     */
    data: ClientMonthlyInfoCreateManyInput | ClientMonthlyInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientMonthlyInfo createManyAndReturn
   */
  export type ClientMonthlyInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientMonthlyInfos.
     */
    data: ClientMonthlyInfoCreateManyInput | ClientMonthlyInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientMonthlyInfo update
   */
  export type ClientMonthlyInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientMonthlyInfo.
     */
    data: XOR<ClientMonthlyInfoUpdateInput, ClientMonthlyInfoUncheckedUpdateInput>
    /**
     * Choose, which ClientMonthlyInfo to update.
     */
    where: ClientMonthlyInfoWhereUniqueInput
  }

  /**
   * ClientMonthlyInfo updateMany
   */
  export type ClientMonthlyInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientMonthlyInfos.
     */
    data: XOR<ClientMonthlyInfoUpdateManyMutationInput, ClientMonthlyInfoUncheckedUpdateManyInput>
    /**
     * Filter which ClientMonthlyInfos to update
     */
    where?: ClientMonthlyInfoWhereInput
  }

  /**
   * ClientMonthlyInfo upsert
   */
  export type ClientMonthlyInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientMonthlyInfo to update in case it exists.
     */
    where: ClientMonthlyInfoWhereUniqueInput
    /**
     * In case the ClientMonthlyInfo found by the `where` argument doesn't exist, create a new ClientMonthlyInfo with this data.
     */
    create: XOR<ClientMonthlyInfoCreateInput, ClientMonthlyInfoUncheckedCreateInput>
    /**
     * In case the ClientMonthlyInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientMonthlyInfoUpdateInput, ClientMonthlyInfoUncheckedUpdateInput>
  }

  /**
   * ClientMonthlyInfo delete
   */
  export type ClientMonthlyInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
    /**
     * Filter which ClientMonthlyInfo to delete.
     */
    where: ClientMonthlyInfoWhereUniqueInput
  }

  /**
   * ClientMonthlyInfo deleteMany
   */
  export type ClientMonthlyInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientMonthlyInfos to delete
     */
    where?: ClientMonthlyInfoWhereInput
  }

  /**
   * ClientMonthlyInfo without action
   */
  export type ClientMonthlyInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMonthlyInfo
     */
    select?: ClientMonthlyInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMonthlyInfoInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    stages: number | null
  }

  export type PlanSumAggregateOutputType = {
    stages: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    projectId: string | null
    costCenterId: string | null
    stages: number | null
    systemType: string | null
    installationType: string | null
    installationDetail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    projectId: string | null
    costCenterId: string | null
    stages: number | null
    systemType: string | null
    installationType: string | null
    installationDetail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    projectId: number
    costCenterId: number
    stages: number
    systemType: number
    installationType: number
    installationDetail: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    stages?: true
  }

  export type PlanSumAggregateInputType = {
    stages?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    projectId?: true
    costCenterId?: true
    stages?: true
    systemType?: true
    installationType?: true
    installationDetail?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    projectId?: true
    costCenterId?: true
    stages?: true
    systemType?: true
    installationType?: true
    installationDetail?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    projectId?: true
    costCenterId?: true
    stages?: true
    systemType?: true
    installationType?: true
    installationDetail?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    imageUrl: string
    projectId: string | null
    costCenterId: string | null
    stages: number
    systemType: string | null
    installationType: string | null
    installationDetail: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    projectId?: boolean
    costCenterId?: boolean
    stages?: boolean
    systemType?: boolean
    installationType?: boolean
    installationDetail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | Plan$projectArgs<ExtArgs>
    costCenter?: boolean | Plan$costCenterArgs<ExtArgs>
    marks?: boolean | Plan$marksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    projectId?: boolean
    costCenterId?: boolean
    stages?: boolean
    systemType?: boolean
    installationType?: boolean
    installationDetail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    project?: boolean | Plan$projectArgs<ExtArgs>
    costCenter?: boolean | Plan$costCenterArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    projectId?: boolean
    costCenterId?: boolean
    stages?: boolean
    systemType?: boolean
    installationType?: boolean
    installationDetail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Plan$projectArgs<ExtArgs>
    costCenter?: boolean | Plan$costCenterArgs<ExtArgs>
    marks?: boolean | Plan$marksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Plan$projectArgs<ExtArgs>
    costCenter?: boolean | Plan$costCenterArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      costCenter: Prisma.$CostCenterPayload<ExtArgs> | null
      marks: Prisma.$PlanMarkPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      imageUrl: string
      projectId: string | null
      costCenterId: string | null
      stages: number
      systemType: string | null
      installationType: string | null
      installationDetail: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Plan$projectArgs<ExtArgs> = {}>(args?: Subset<T, Plan$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    costCenter<T extends Plan$costCenterArgs<ExtArgs> = {}>(args?: Subset<T, Plan$costCenterArgs<ExtArgs>>): Prisma__CostCenterClient<$Result.GetResult<Prisma.$CostCenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    marks<T extends Plan$marksArgs<ExtArgs> = {}>(args?: Subset<T, Plan$marksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly imageUrl: FieldRef<"Plan", 'String'>
    readonly projectId: FieldRef<"Plan", 'String'>
    readonly costCenterId: FieldRef<"Plan", 'String'>
    readonly stages: FieldRef<"Plan", 'Int'>
    readonly systemType: FieldRef<"Plan", 'String'>
    readonly installationType: FieldRef<"Plan", 'String'>
    readonly installationDetail: FieldRef<"Plan", 'String'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly companyId: FieldRef<"Plan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.project
   */
  export type Plan$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Plan.costCenter
   */
  export type Plan$costCenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCenter
     */
    select?: CostCenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCenterInclude<ExtArgs> | null
    where?: CostCenterWhereInput
  }

  /**
   * Plan.marks
   */
  export type Plan$marksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    where?: PlanMarkWhereInput
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    cursor?: PlanMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanMark
   */

  export type AggregatePlanMark = {
    _count: PlanMarkCountAggregateOutputType | null
    _avg: PlanMarkAvgAggregateOutputType | null
    _sum: PlanMarkSumAggregateOutputType | null
    _min: PlanMarkMinAggregateOutputType | null
    _max: PlanMarkMaxAggregateOutputType | null
  }

  export type PlanMarkAvgAggregateOutputType = {
    x: number | null
    y: number | null
    meters: number | null
    stage: number | null
  }

  export type PlanMarkSumAggregateOutputType = {
    x: number | null
    y: number | null
    meters: number | null
    stage: number | null
  }

  export type PlanMarkMinAggregateOutputType = {
    id: string | null
    planId: string | null
    userId: string | null
    x: number | null
    y: number | null
    type: string | null
    date: Date | null
    meters: number | null
    comment: string | null
    imageUrl: string | null
    stage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMarkMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    userId: string | null
    x: number | null
    y: number | null
    type: string | null
    date: Date | null
    meters: number | null
    comment: string | null
    imageUrl: string | null
    stage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMarkCountAggregateOutputType = {
    id: number
    planId: number
    userId: number
    x: number
    y: number
    points: number
    type: number
    date: number
    meters: number
    comment: number
    imageUrl: number
    stage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanMarkAvgAggregateInputType = {
    x?: true
    y?: true
    meters?: true
    stage?: true
  }

  export type PlanMarkSumAggregateInputType = {
    x?: true
    y?: true
    meters?: true
    stage?: true
  }

  export type PlanMarkMinAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    x?: true
    y?: true
    type?: true
    date?: true
    meters?: true
    comment?: true
    imageUrl?: true
    stage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMarkMaxAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    x?: true
    y?: true
    type?: true
    date?: true
    meters?: true
    comment?: true
    imageUrl?: true
    stage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMarkCountAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    x?: true
    y?: true
    points?: true
    type?: true
    date?: true
    meters?: true
    comment?: true
    imageUrl?: true
    stage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanMarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMark to aggregate.
     */
    where?: PlanMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMarks to fetch.
     */
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanMarks
    **/
    _count?: true | PlanMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanMarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanMarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMarkMaxAggregateInputType
  }

  export type GetPlanMarkAggregateType<T extends PlanMarkAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanMark[P]>
      : GetScalarType<T[P], AggregatePlanMark[P]>
  }




  export type PlanMarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMarkWhereInput
    orderBy?: PlanMarkOrderByWithAggregationInput | PlanMarkOrderByWithAggregationInput[]
    by: PlanMarkScalarFieldEnum[] | PlanMarkScalarFieldEnum
    having?: PlanMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanMarkCountAggregateInputType | true
    _avg?: PlanMarkAvgAggregateInputType
    _sum?: PlanMarkSumAggregateInputType
    _min?: PlanMarkMinAggregateInputType
    _max?: PlanMarkMaxAggregateInputType
  }

  export type PlanMarkGroupByOutputType = {
    id: string
    planId: string
    userId: string
    x: number
    y: number
    points: JsonValue | null
    type: string
    date: Date
    meters: number
    comment: string | null
    imageUrl: string | null
    stage: number
    createdAt: Date
    updatedAt: Date
    _count: PlanMarkCountAggregateOutputType | null
    _avg: PlanMarkAvgAggregateOutputType | null
    _sum: PlanMarkSumAggregateOutputType | null
    _min: PlanMarkMinAggregateOutputType | null
    _max: PlanMarkMaxAggregateOutputType | null
  }

  type GetPlanMarkGroupByPayload<T extends PlanMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanMarkGroupByOutputType[P]>
            : GetScalarType<T[P], PlanMarkGroupByOutputType[P]>
        }
      >
    >


  export type PlanMarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    userId?: boolean
    x?: boolean
    y?: boolean
    points?: boolean
    type?: boolean
    date?: boolean
    meters?: boolean
    comment?: boolean
    imageUrl?: boolean
    stage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    workers?: boolean | PlanMark$workersArgs<ExtArgs>
    _count?: boolean | PlanMarkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planMark"]>

  export type PlanMarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    userId?: boolean
    x?: boolean
    y?: boolean
    points?: boolean
    type?: boolean
    date?: boolean
    meters?: boolean
    comment?: boolean
    imageUrl?: boolean
    stage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planMark"]>

  export type PlanMarkSelectScalar = {
    id?: boolean
    planId?: boolean
    userId?: boolean
    x?: boolean
    y?: boolean
    points?: boolean
    type?: boolean
    date?: boolean
    meters?: boolean
    comment?: boolean
    imageUrl?: boolean
    stage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanMarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    workers?: boolean | PlanMark$workersArgs<ExtArgs>
    _count?: boolean | PlanMarkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanMarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlanMarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanMark"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      workers: Prisma.$WorkerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      userId: string
      x: number
      y: number
      points: Prisma.JsonValue | null
      type: string
      date: Date
      meters: number
      comment: string | null
      imageUrl: string | null
      stage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planMark"]>
    composites: {}
  }

  type PlanMarkGetPayload<S extends boolean | null | undefined | PlanMarkDefaultArgs> = $Result.GetResult<Prisma.$PlanMarkPayload, S>

  type PlanMarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanMarkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanMarkCountAggregateInputType | true
    }

  export interface PlanMarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanMark'], meta: { name: 'PlanMark' } }
    /**
     * Find zero or one PlanMark that matches the filter.
     * @param {PlanMarkFindUniqueArgs} args - Arguments to find a PlanMark
     * @example
     * // Get one PlanMark
     * const planMark = await prisma.planMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanMarkFindUniqueArgs>(args: SelectSubset<T, PlanMarkFindUniqueArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanMark that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanMarkFindUniqueOrThrowArgs} args - Arguments to find a PlanMark
     * @example
     * // Get one PlanMark
     * const planMark = await prisma.planMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanMarkFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanMarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkFindFirstArgs} args - Arguments to find a PlanMark
     * @example
     * // Get one PlanMark
     * const planMark = await prisma.planMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanMarkFindFirstArgs>(args?: SelectSubset<T, PlanMarkFindFirstArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkFindFirstOrThrowArgs} args - Arguments to find a PlanMark
     * @example
     * // Get one PlanMark
     * const planMark = await prisma.planMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanMarkFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanMarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanMarks
     * const planMarks = await prisma.planMark.findMany()
     * 
     * // Get first 10 PlanMarks
     * const planMarks = await prisma.planMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planMarkWithIdOnly = await prisma.planMark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanMarkFindManyArgs>(args?: SelectSubset<T, PlanMarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanMark.
     * @param {PlanMarkCreateArgs} args - Arguments to create a PlanMark.
     * @example
     * // Create one PlanMark
     * const PlanMark = await prisma.planMark.create({
     *   data: {
     *     // ... data to create a PlanMark
     *   }
     * })
     * 
     */
    create<T extends PlanMarkCreateArgs>(args: SelectSubset<T, PlanMarkCreateArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanMarks.
     * @param {PlanMarkCreateManyArgs} args - Arguments to create many PlanMarks.
     * @example
     * // Create many PlanMarks
     * const planMark = await prisma.planMark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanMarkCreateManyArgs>(args?: SelectSubset<T, PlanMarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanMarks and returns the data saved in the database.
     * @param {PlanMarkCreateManyAndReturnArgs} args - Arguments to create many PlanMarks.
     * @example
     * // Create many PlanMarks
     * const planMark = await prisma.planMark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanMarks and only return the `id`
     * const planMarkWithIdOnly = await prisma.planMark.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanMarkCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanMarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanMark.
     * @param {PlanMarkDeleteArgs} args - Arguments to delete one PlanMark.
     * @example
     * // Delete one PlanMark
     * const PlanMark = await prisma.planMark.delete({
     *   where: {
     *     // ... filter to delete one PlanMark
     *   }
     * })
     * 
     */
    delete<T extends PlanMarkDeleteArgs>(args: SelectSubset<T, PlanMarkDeleteArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanMark.
     * @param {PlanMarkUpdateArgs} args - Arguments to update one PlanMark.
     * @example
     * // Update one PlanMark
     * const planMark = await prisma.planMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanMarkUpdateArgs>(args: SelectSubset<T, PlanMarkUpdateArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanMarks.
     * @param {PlanMarkDeleteManyArgs} args - Arguments to filter PlanMarks to delete.
     * @example
     * // Delete a few PlanMarks
     * const { count } = await prisma.planMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanMarkDeleteManyArgs>(args?: SelectSubset<T, PlanMarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanMarks
     * const planMark = await prisma.planMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanMarkUpdateManyArgs>(args: SelectSubset<T, PlanMarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanMark.
     * @param {PlanMarkUpsertArgs} args - Arguments to update or create a PlanMark.
     * @example
     * // Update or create a PlanMark
     * const planMark = await prisma.planMark.upsert({
     *   create: {
     *     // ... data to create a PlanMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanMark we want to update
     *   }
     * })
     */
    upsert<T extends PlanMarkUpsertArgs>(args: SelectSubset<T, PlanMarkUpsertArgs<ExtArgs>>): Prisma__PlanMarkClient<$Result.GetResult<Prisma.$PlanMarkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkCountArgs} args - Arguments to filter PlanMarks to count.
     * @example
     * // Count the number of PlanMarks
     * const count = await prisma.planMark.count({
     *   where: {
     *     // ... the filter for the PlanMarks we want to count
     *   }
     * })
    **/
    count<T extends PlanMarkCountArgs>(
      args?: Subset<T, PlanMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanMarkAggregateArgs>(args: Subset<T, PlanMarkAggregateArgs>): Prisma.PrismaPromise<GetPlanMarkAggregateType<T>>

    /**
     * Group by PlanMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanMarkGroupByArgs['orderBy'] }
        : { orderBy?: PlanMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanMark model
   */
  readonly fields: PlanMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanMarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workers<T extends PlanMark$workersArgs<ExtArgs> = {}>(args?: Subset<T, PlanMark$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanMark model
   */ 
  interface PlanMarkFieldRefs {
    readonly id: FieldRef<"PlanMark", 'String'>
    readonly planId: FieldRef<"PlanMark", 'String'>
    readonly userId: FieldRef<"PlanMark", 'String'>
    readonly x: FieldRef<"PlanMark", 'Float'>
    readonly y: FieldRef<"PlanMark", 'Float'>
    readonly points: FieldRef<"PlanMark", 'Json'>
    readonly type: FieldRef<"PlanMark", 'String'>
    readonly date: FieldRef<"PlanMark", 'DateTime'>
    readonly meters: FieldRef<"PlanMark", 'Float'>
    readonly comment: FieldRef<"PlanMark", 'String'>
    readonly imageUrl: FieldRef<"PlanMark", 'String'>
    readonly stage: FieldRef<"PlanMark", 'Int'>
    readonly createdAt: FieldRef<"PlanMark", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanMark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanMark findUnique
   */
  export type PlanMarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter, which PlanMark to fetch.
     */
    where: PlanMarkWhereUniqueInput
  }

  /**
   * PlanMark findUniqueOrThrow
   */
  export type PlanMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter, which PlanMark to fetch.
     */
    where: PlanMarkWhereUniqueInput
  }

  /**
   * PlanMark findFirst
   */
  export type PlanMarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter, which PlanMark to fetch.
     */
    where?: PlanMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMarks to fetch.
     */
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMarks.
     */
    cursor?: PlanMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMarks.
     */
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * PlanMark findFirstOrThrow
   */
  export type PlanMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter, which PlanMark to fetch.
     */
    where?: PlanMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMarks to fetch.
     */
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMarks.
     */
    cursor?: PlanMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMarks.
     */
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * PlanMark findMany
   */
  export type PlanMarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter, which PlanMarks to fetch.
     */
    where?: PlanMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMarks to fetch.
     */
    orderBy?: PlanMarkOrderByWithRelationInput | PlanMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanMarks.
     */
    cursor?: PlanMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMarks.
     */
    skip?: number
    distinct?: PlanMarkScalarFieldEnum | PlanMarkScalarFieldEnum[]
  }

  /**
   * PlanMark create
   */
  export type PlanMarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanMark.
     */
    data: XOR<PlanMarkCreateInput, PlanMarkUncheckedCreateInput>
  }

  /**
   * PlanMark createMany
   */
  export type PlanMarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanMarks.
     */
    data: PlanMarkCreateManyInput | PlanMarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanMark createManyAndReturn
   */
  export type PlanMarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanMarks.
     */
    data: PlanMarkCreateManyInput | PlanMarkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanMark update
   */
  export type PlanMarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanMark.
     */
    data: XOR<PlanMarkUpdateInput, PlanMarkUncheckedUpdateInput>
    /**
     * Choose, which PlanMark to update.
     */
    where: PlanMarkWhereUniqueInput
  }

  /**
   * PlanMark updateMany
   */
  export type PlanMarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanMarks.
     */
    data: XOR<PlanMarkUpdateManyMutationInput, PlanMarkUncheckedUpdateManyInput>
    /**
     * Filter which PlanMarks to update
     */
    where?: PlanMarkWhereInput
  }

  /**
   * PlanMark upsert
   */
  export type PlanMarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanMark to update in case it exists.
     */
    where: PlanMarkWhereUniqueInput
    /**
     * In case the PlanMark found by the `where` argument doesn't exist, create a new PlanMark with this data.
     */
    create: XOR<PlanMarkCreateInput, PlanMarkUncheckedCreateInput>
    /**
     * In case the PlanMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanMarkUpdateInput, PlanMarkUncheckedUpdateInput>
  }

  /**
   * PlanMark delete
   */
  export type PlanMarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
    /**
     * Filter which PlanMark to delete.
     */
    where: PlanMarkWhereUniqueInput
  }

  /**
   * PlanMark deleteMany
   */
  export type PlanMarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMarks to delete
     */
    where?: PlanMarkWhereInput
  }

  /**
   * PlanMark.workers
   */
  export type PlanMark$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * PlanMark without action
   */
  export type PlanMarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMark
     */
    select?: PlanMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMarkInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    allowedSections: 'allowedSections',
    assignedProjectIds: 'assignedProjectIds',
    activeCompanyId: 'activeCompanyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    rut: 'rut',
    name: 'name',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    rut: 'rut',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    clientId: 'clientId',
    progress: 'progress',
    budget: 'budget',
    address: 'address',
    startDate: 'startDate',
    endDate: 'endDate',
    workerIds: 'workerIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CostCenterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    budget: 'budget',
    createAt: 'createAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    rut: 'rut',
    name: 'name',
    role: 'role',
    specialty: 'specialty',
    email: 'email',
    phone: 'phone',
    experienceYears: 'experienceYears',
    certifications: 'certifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const JobTitleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type JobTitleScalarFieldEnum = (typeof JobTitleScalarFieldEnum)[keyof typeof JobTitleScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    dueDate: 'dueDate',
    status: 'status',
    type: 'type',
    emissionType: 'emissionType',
    purchaseOrderNumber: 'purchaseOrderNumber',
    dispatchGuideNumber: 'dispatchGuideNumber',
    netAmount: 'netAmount',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    clientId: 'clientId',
    projectId: 'projectId',
    costCenterId: 'costCenterId',
    relatedInvoiceId: 'relatedInvoiceId',
    isPaid: 'isPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    invoiceId: 'invoiceId'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const DailyReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    content: 'content',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type DailyReportScalarFieldEnum = (typeof DailyReportScalarFieldEnum)[keyof typeof DailyReportScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    number: 'number',
    provider: 'provider',
    date: 'date',
    status: 'status',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    purchaseOrderId: 'purchaseOrderId'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    type: 'type',
    projectId: 'projectId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    requirementId: 'requirementId',
    status: 'status',
    companyId: 'companyId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentRequirementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    month: 'month',
    year: 'year',
    status: 'status',
    dueDate: 'dueDate',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type DocumentRequirementScalarFieldEnum = (typeof DocumentRequirementScalarFieldEnum)[keyof typeof DocumentRequirementScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    unit: 'unit',
    minStock: 'minStock',
    currentStock: 'currentStock',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    quantity: 'quantity',
    date: 'date',
    description: 'description',
    materialId: 'materialId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    companyId: 'companyId'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const ClientMonthlyInfoScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    month: 'month',
    year: 'year',
    edpDate: 'edpDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ClientMonthlyInfoScalarFieldEnum = (typeof ClientMonthlyInfoScalarFieldEnum)[keyof typeof ClientMonthlyInfoScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    projectId: 'projectId',
    costCenterId: 'costCenterId',
    stages: 'stages',
    systemType: 'systemType',
    installationType: 'installationType',
    installationDetail: 'installationDetail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanMarkScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    userId: 'userId',
    x: 'x',
    y: 'y',
    points: 'points',
    type: 'type',
    date: 'date',
    meters: 'meters',
    comment: 'comment',
    imageUrl: 'imageUrl',
    stage: 'stage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanMarkScalarFieldEnum = (typeof PlanMarkScalarFieldEnum)[keyof typeof PlanMarkScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    allowedSections?: StringNullableListFilter<"User">
    assignedProjectIds?: StringNullableListFilter<"User">
    activeCompanyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companies?: CompanyListRelationFilter
    dailyReports?: DailyReportListRelationFilter
    planMarks?: PlanMarkListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    allowedSections?: SortOrder
    assignedProjectIds?: SortOrder
    activeCompanyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companies?: CompanyOrderByRelationAggregateInput
    dailyReports?: DailyReportOrderByRelationAggregateInput
    planMarks?: PlanMarkOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    allowedSections?: StringNullableListFilter<"User">
    assignedProjectIds?: StringNullableListFilter<"User">
    activeCompanyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companies?: CompanyListRelationFilter
    dailyReports?: DailyReportListRelationFilter
    planMarks?: PlanMarkListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    allowedSections?: SortOrder
    assignedProjectIds?: SortOrder
    activeCompanyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    allowedSections?: StringNullableListFilter<"User">
    assignedProjectIds?: StringNullableListFilter<"User">
    activeCompanyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    rut?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    projects?: ProjectListRelationFilter
    invoices?: InvoiceListRelationFilter
    documents?: DocumentListRelationFilter
    requirements?: DocumentRequirementListRelationFilter
    monthlyInfo?: ClientMonthlyInfoListRelationFilter
    workers?: WorkerListRelationFilter
    crews?: CrewListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    costCenters?: CostCenterListRelationFilter
    DailyReport?: DailyReportListRelationFilter
    Material?: MaterialListRelationFilter
    Plan?: PlanListRelationFilter
    jobTitles?: JobTitleListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    requirements?: DocumentRequirementOrderByRelationAggregateInput
    monthlyInfo?: ClientMonthlyInfoOrderByRelationAggregateInput
    workers?: WorkerOrderByRelationAggregateInput
    crews?: CrewOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    costCenters?: CostCenterOrderByRelationAggregateInput
    DailyReport?: DailyReportOrderByRelationAggregateInput
    Material?: MaterialOrderByRelationAggregateInput
    Plan?: PlanOrderByRelationAggregateInput
    jobTitles?: JobTitleOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rut?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    projects?: ProjectListRelationFilter
    invoices?: InvoiceListRelationFilter
    documents?: DocumentListRelationFilter
    requirements?: DocumentRequirementListRelationFilter
    monthlyInfo?: ClientMonthlyInfoListRelationFilter
    workers?: WorkerListRelationFilter
    crews?: CrewListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    costCenters?: CostCenterListRelationFilter
    DailyReport?: DailyReportListRelationFilter
    Material?: MaterialListRelationFilter
    Plan?: PlanListRelationFilter
    jobTitles?: JobTitleListRelationFilter
  }, "id" | "rut">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    rut?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    rut?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    companyId?: StringFilter<"Client"> | string
    projects?: ProjectListRelationFilter
    invoices?: InvoiceListRelationFilter
    documents?: DocumentListRelationFilter
    requirements?: DocumentRequirementListRelationFilter
    monthlyInfo?: ClientMonthlyInfoListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    requirements?: DocumentRequirementOrderByRelationAggregateInput
    monthlyInfo?: ClientMonthlyInfoOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rut_companyId?: ClientRutCompanyIdCompoundUniqueInput
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    rut?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    companyId?: StringFilter<"Client"> | string
    projects?: ProjectListRelationFilter
    invoices?: InvoiceListRelationFilter
    documents?: DocumentListRelationFilter
    requirements?: DocumentRequirementListRelationFilter
    monthlyInfo?: ClientMonthlyInfoListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "rut_companyId">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    rut?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    companyId?: StringWithAggregatesFilter<"Client"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    progress?: IntFilter<"Project"> | number
    budget?: FloatFilter<"Project"> | number
    address?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    workerIds?: StringNullableListFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringFilter<"Project"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    crews?: CrewListRelationFilter
    invoices?: InvoiceListRelationFilter
    dailyReports?: DailyReportListRelationFilter
    documents?: DocumentListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    plans?: PlanListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    clientId?: SortOrderInput | SortOrder
    progress?: SortOrder
    budget?: SortOrder
    address?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    workerIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    client?: ClientOrderByWithRelationInput
    crews?: CrewOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    dailyReports?: DailyReportOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    plans?: PlanOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    progress?: IntFilter<"Project"> | number
    budget?: FloatFilter<"Project"> | number
    address?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    workerIds?: StringNullableListFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringFilter<"Project"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    crews?: CrewListRelationFilter
    invoices?: InvoiceListRelationFilter
    dailyReports?: DailyReportListRelationFilter
    documents?: DocumentListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    plans?: PlanListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    clientId?: SortOrderInput | SortOrder
    progress?: SortOrder
    budget?: SortOrder
    address?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    workerIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    clientId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    progress?: IntWithAggregatesFilter<"Project"> | number
    budget?: FloatWithAggregatesFilter<"Project"> | number
    address?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    workerIds?: StringNullableListFilter<"Project">
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    companyId?: StringWithAggregatesFilter<"Project"> | string
  }

  export type CostCenterWhereInput = {
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    id?: StringFilter<"CostCenter"> | string
    code?: StringFilter<"CostCenter"> | string
    name?: StringFilter<"CostCenter"> | string
    budget?: FloatFilter<"CostCenter"> | number
    createAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
    companyId?: StringFilter<"CostCenter"> | string
    invoices?: InvoiceListRelationFilter
    plans?: PlanListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CostCenterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    budget?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    plans?: PlanOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CostCenterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code_companyId?: CostCenterCodeCompanyIdCompoundUniqueInput
    AND?: CostCenterWhereInput | CostCenterWhereInput[]
    OR?: CostCenterWhereInput[]
    NOT?: CostCenterWhereInput | CostCenterWhereInput[]
    code?: StringFilter<"CostCenter"> | string
    name?: StringFilter<"CostCenter"> | string
    budget?: FloatFilter<"CostCenter"> | number
    createAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
    companyId?: StringFilter<"CostCenter"> | string
    invoices?: InvoiceListRelationFilter
    plans?: PlanListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "code_companyId">

  export type CostCenterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    budget?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: CostCenterCountOrderByAggregateInput
    _avg?: CostCenterAvgOrderByAggregateInput
    _max?: CostCenterMaxOrderByAggregateInput
    _min?: CostCenterMinOrderByAggregateInput
    _sum?: CostCenterSumOrderByAggregateInput
  }

  export type CostCenterScalarWhereWithAggregatesInput = {
    AND?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    OR?: CostCenterScalarWhereWithAggregatesInput[]
    NOT?: CostCenterScalarWhereWithAggregatesInput | CostCenterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostCenter"> | string
    code?: StringWithAggregatesFilter<"CostCenter"> | string
    name?: StringWithAggregatesFilter<"CostCenter"> | string
    budget?: FloatWithAggregatesFilter<"CostCenter"> | number
    createAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostCenter"> | Date | string
    companyId?: StringWithAggregatesFilter<"CostCenter"> | string
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: StringFilter<"Worker"> | string
    rut?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    role?: StringNullableFilter<"Worker"> | string | null
    specialty?: StringNullableFilter<"Worker"> | string | null
    email?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    experienceYears?: IntNullableFilter<"Worker"> | number | null
    certifications?: StringNullableListFilter<"Worker">
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    companyId?: StringFilter<"Worker"> | string
    crews?: CrewListRelationFilter
    planMarks?: PlanMarkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    experienceYears?: SortOrderInput | SortOrder
    certifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    crews?: CrewOrderByRelationAggregateInput
    planMarks?: PlanMarkOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rut_companyId?: WorkerRutCompanyIdCompoundUniqueInput
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    rut?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    role?: StringNullableFilter<"Worker"> | string | null
    specialty?: StringNullableFilter<"Worker"> | string | null
    email?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    experienceYears?: IntNullableFilter<"Worker"> | number | null
    certifications?: StringNullableListFilter<"Worker">
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    companyId?: StringFilter<"Worker"> | string
    crews?: CrewListRelationFilter
    planMarks?: PlanMarkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "rut_companyId">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    experienceYears?: SortOrderInput | SortOrder
    certifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _avg?: WorkerAvgOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
    _sum?: WorkerSumOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worker"> | string
    rut?: StringWithAggregatesFilter<"Worker"> | string
    name?: StringWithAggregatesFilter<"Worker"> | string
    role?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    specialty?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    email?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    experienceYears?: IntNullableWithAggregatesFilter<"Worker"> | number | null
    certifications?: StringNullableListFilter<"Worker">
    createdAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    companyId?: StringWithAggregatesFilter<"Worker"> | string
  }

  export type CrewWhereInput = {
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    role?: StringNullableFilter<"Crew"> | string | null
    projectId?: StringNullableFilter<"Crew"> | string | null
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
    companyId?: StringFilter<"Crew"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    workers?: WorkerListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    workers?: WorkerOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    name?: StringFilter<"Crew"> | string
    role?: StringNullableFilter<"Crew"> | string | null
    projectId?: StringNullableFilter<"Crew"> | string | null
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
    companyId?: StringFilter<"Crew"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    workers?: WorkerListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    OR?: CrewScalarWhereWithAggregatesInput[]
    NOT?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crew"> | string
    name?: StringWithAggregatesFilter<"Crew"> | string
    role?: StringNullableWithAggregatesFilter<"Crew"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Crew"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    companyId?: StringWithAggregatesFilter<"Crew"> | string
  }

  export type JobTitleWhereInput = {
    AND?: JobTitleWhereInput | JobTitleWhereInput[]
    OR?: JobTitleWhereInput[]
    NOT?: JobTitleWhereInput | JobTitleWhereInput[]
    id?: StringFilter<"JobTitle"> | string
    name?: StringFilter<"JobTitle"> | string
    description?: StringNullableFilter<"JobTitle"> | string | null
    createdAt?: DateTimeFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeFilter<"JobTitle"> | Date | string
    companyId?: StringNullableFilter<"JobTitle"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type JobTitleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type JobTitleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobTitleWhereInput | JobTitleWhereInput[]
    OR?: JobTitleWhereInput[]
    NOT?: JobTitleWhereInput | JobTitleWhereInput[]
    name?: StringFilter<"JobTitle"> | string
    description?: StringNullableFilter<"JobTitle"> | string | null
    createdAt?: DateTimeFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeFilter<"JobTitle"> | Date | string
    companyId?: StringNullableFilter<"JobTitle"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type JobTitleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: JobTitleCountOrderByAggregateInput
    _max?: JobTitleMaxOrderByAggregateInput
    _min?: JobTitleMinOrderByAggregateInput
  }

  export type JobTitleScalarWhereWithAggregatesInput = {
    AND?: JobTitleScalarWhereWithAggregatesInput | JobTitleScalarWhereWithAggregatesInput[]
    OR?: JobTitleScalarWhereWithAggregatesInput[]
    NOT?: JobTitleScalarWhereWithAggregatesInput | JobTitleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobTitle"> | string
    name?: StringWithAggregatesFilter<"JobTitle"> | string
    description?: StringNullableWithAggregatesFilter<"JobTitle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobTitle"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"JobTitle"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    status?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    emissionType?: StringFilter<"Invoice"> | string
    purchaseOrderNumber?: StringNullableFilter<"Invoice"> | string | null
    dispatchGuideNumber?: StringNullableFilter<"Invoice"> | string | null
    netAmount?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    clientId?: StringNullableFilter<"Invoice"> | string | null
    projectId?: StringNullableFilter<"Invoice"> | string | null
    costCenterId?: StringNullableFilter<"Invoice"> | string | null
    relatedInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    isPaid?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    items?: InvoiceItemListRelationFilter
    relatedInvoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    relatedByInvoices?: InvoiceListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    emissionType?: SortOrder
    purchaseOrderNumber?: SortOrderInput | SortOrder
    dispatchGuideNumber?: SortOrderInput | SortOrder
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    costCenterId?: SortOrderInput | SortOrder
    relatedInvoiceId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    client?: ClientOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    costCenter?: CostCenterOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    relatedInvoice?: InvoiceOrderByWithRelationInput
    relatedByInvoices?: InvoiceOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    number?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    status?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    emissionType?: StringFilter<"Invoice"> | string
    purchaseOrderNumber?: StringNullableFilter<"Invoice"> | string | null
    dispatchGuideNumber?: StringNullableFilter<"Invoice"> | string | null
    netAmount?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    clientId?: StringNullableFilter<"Invoice"> | string | null
    projectId?: StringNullableFilter<"Invoice"> | string | null
    costCenterId?: StringNullableFilter<"Invoice"> | string | null
    relatedInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    isPaid?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    items?: InvoiceItemListRelationFilter
    relatedInvoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    relatedByInvoices?: InvoiceListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    emissionType?: SortOrder
    purchaseOrderNumber?: SortOrderInput | SortOrder
    dispatchGuideNumber?: SortOrderInput | SortOrder
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    costCenterId?: SortOrderInput | SortOrder
    relatedInvoiceId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    number?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    status?: StringWithAggregatesFilter<"Invoice"> | string
    type?: StringWithAggregatesFilter<"Invoice"> | string
    emissionType?: StringWithAggregatesFilter<"Invoice"> | string
    purchaseOrderNumber?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    dispatchGuideNumber?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    netAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    clientId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    costCenterId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    relatedInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    isPaid?: BoolWithAggregatesFilter<"Invoice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    companyId?: StringWithAggregatesFilter<"Invoice"> | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    invoiceId?: StringFilter<"InvoiceItem"> | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoiceId?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    invoiceId?: StringFilter<"InvoiceItem"> | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoiceId?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
  }

  export type DailyReportWhereInput = {
    AND?: DailyReportWhereInput | DailyReportWhereInput[]
    OR?: DailyReportWhereInput[]
    NOT?: DailyReportWhereInput | DailyReportWhereInput[]
    id?: StringFilter<"DailyReport"> | string
    userId?: StringFilter<"DailyReport"> | string
    date?: DateTimeFilter<"DailyReport"> | Date | string
    content?: StringFilter<"DailyReport"> | string
    projectId?: StringNullableFilter<"DailyReport"> | string | null
    createdAt?: DateTimeFilter<"DailyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReport"> | Date | string
    companyId?: StringFilter<"DailyReport"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DailyReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DailyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyReportWhereInput | DailyReportWhereInput[]
    OR?: DailyReportWhereInput[]
    NOT?: DailyReportWhereInput | DailyReportWhereInput[]
    userId?: StringFilter<"DailyReport"> | string
    date?: DateTimeFilter<"DailyReport"> | Date | string
    content?: StringFilter<"DailyReport"> | string
    projectId?: StringNullableFilter<"DailyReport"> | string | null
    createdAt?: DateTimeFilter<"DailyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReport"> | Date | string
    companyId?: StringFilter<"DailyReport"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DailyReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: DailyReportCountOrderByAggregateInput
    _max?: DailyReportMaxOrderByAggregateInput
    _min?: DailyReportMinOrderByAggregateInput
  }

  export type DailyReportScalarWhereWithAggregatesInput = {
    AND?: DailyReportScalarWhereWithAggregatesInput | DailyReportScalarWhereWithAggregatesInput[]
    OR?: DailyReportScalarWhereWithAggregatesInput[]
    NOT?: DailyReportScalarWhereWithAggregatesInput | DailyReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyReport"> | string
    userId?: StringWithAggregatesFilter<"DailyReport"> | string
    date?: DateTimeWithAggregatesFilter<"DailyReport"> | Date | string
    content?: StringWithAggregatesFilter<"DailyReport"> | string
    projectId?: StringNullableWithAggregatesFilter<"DailyReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyReport"> | Date | string
    companyId?: StringWithAggregatesFilter<"DailyReport"> | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    number?: StringFilter<"PurchaseOrder"> | string
    provider?: StringFilter<"PurchaseOrder"> | string
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    projectId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    companyId?: StringFilter<"PurchaseOrder"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    items?: PurchaseOrderItemListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    provider?: SortOrder
    date?: SortOrder
    status?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number_companyId?: PurchaseOrderNumberCompanyIdCompoundUniqueInput
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    number?: StringFilter<"PurchaseOrder"> | string
    provider?: StringFilter<"PurchaseOrder"> | string
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    projectId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    companyId?: StringFilter<"PurchaseOrder"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    items?: PurchaseOrderItemListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "number_companyId">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    provider?: SortOrder
    date?: SortOrder
    status?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    number?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    provider?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    date?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    projectId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    companyId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    total?: FloatFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    purchaseOrderId?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    description?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    total?: FloatFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    purchaseOrderId?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    description?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    quantity?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    total?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    requirementId?: StringNullableFilter<"Document"> | string | null
    status?: StringFilter<"Document"> | string
    companyId?: StringFilter<"Document"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    requirement?: XOR<DocumentRequirementNullableScalarRelationFilter, DocumentRequirementWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    requirement?: DocumentRequirementOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    requirementId?: StringNullableFilter<"Document"> | string | null
    status?: StringFilter<"Document"> | string
    companyId?: StringFilter<"Document"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    requirement?: XOR<DocumentRequirementNullableScalarRelationFilter, DocumentRequirementWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    projectId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    requirementId?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    projectId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    requirementId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    status?: StringWithAggregatesFilter<"Document"> | string
    companyId?: StringWithAggregatesFilter<"Document"> | string
  }

  export type DocumentRequirementWhereInput = {
    AND?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    OR?: DocumentRequirementWhereInput[]
    NOT?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    id?: StringFilter<"DocumentRequirement"> | string
    name?: StringFilter<"DocumentRequirement"> | string
    description?: StringNullableFilter<"DocumentRequirement"> | string | null
    month?: IntNullableFilter<"DocumentRequirement"> | number | null
    year?: IntNullableFilter<"DocumentRequirement"> | number | null
    status?: StringFilter<"DocumentRequirement"> | string
    dueDate?: DateTimeNullableFilter<"DocumentRequirement"> | Date | string | null
    clientId?: StringFilter<"DocumentRequirement"> | string
    createdAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    companyId?: StringFilter<"DocumentRequirement"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    documents?: DocumentListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DocumentRequirementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    client?: ClientOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DocumentRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    OR?: DocumentRequirementWhereInput[]
    NOT?: DocumentRequirementWhereInput | DocumentRequirementWhereInput[]
    name?: StringFilter<"DocumentRequirement"> | string
    description?: StringNullableFilter<"DocumentRequirement"> | string | null
    month?: IntNullableFilter<"DocumentRequirement"> | number | null
    year?: IntNullableFilter<"DocumentRequirement"> | number | null
    status?: StringFilter<"DocumentRequirement"> | string
    dueDate?: DateTimeNullableFilter<"DocumentRequirement"> | Date | string | null
    clientId?: StringFilter<"DocumentRequirement"> | string
    createdAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    companyId?: StringFilter<"DocumentRequirement"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    documents?: DocumentListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DocumentRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: DocumentRequirementCountOrderByAggregateInput
    _avg?: DocumentRequirementAvgOrderByAggregateInput
    _max?: DocumentRequirementMaxOrderByAggregateInput
    _min?: DocumentRequirementMinOrderByAggregateInput
    _sum?: DocumentRequirementSumOrderByAggregateInput
  }

  export type DocumentRequirementScalarWhereWithAggregatesInput = {
    AND?: DocumentRequirementScalarWhereWithAggregatesInput | DocumentRequirementScalarWhereWithAggregatesInput[]
    OR?: DocumentRequirementScalarWhereWithAggregatesInput[]
    NOT?: DocumentRequirementScalarWhereWithAggregatesInput | DocumentRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentRequirement"> | string
    name?: StringWithAggregatesFilter<"DocumentRequirement"> | string
    description?: StringNullableWithAggregatesFilter<"DocumentRequirement"> | string | null
    month?: IntNullableWithAggregatesFilter<"DocumentRequirement"> | number | null
    year?: IntNullableWithAggregatesFilter<"DocumentRequirement"> | number | null
    status?: StringWithAggregatesFilter<"DocumentRequirement"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"DocumentRequirement"> | Date | string | null
    clientId?: StringWithAggregatesFilter<"DocumentRequirement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentRequirement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentRequirement"> | Date | string
    companyId?: StringWithAggregatesFilter<"DocumentRequirement"> | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    code?: StringNullableFilter<"Material"> | string | null
    name?: StringFilter<"Material"> | string
    unit?: StringFilter<"Material"> | string
    minStock?: FloatFilter<"Material"> | number
    currentStock?: FloatFilter<"Material"> | number
    price?: FloatFilter<"Material"> | number
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    companyId?: StringFilter<"Material"> | string
    movements?: InventoryMovementListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrder
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    movements?: InventoryMovementOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code_companyId?: MaterialCodeCompanyIdCompoundUniqueInput
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    code?: StringNullableFilter<"Material"> | string | null
    name?: StringFilter<"Material"> | string
    unit?: StringFilter<"Material"> | string
    minStock?: FloatFilter<"Material"> | number
    currentStock?: FloatFilter<"Material"> | number
    price?: FloatFilter<"Material"> | number
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    companyId?: StringFilter<"Material"> | string
    movements?: InventoryMovementListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "code_companyId">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrder
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    code?: StringNullableWithAggregatesFilter<"Material"> | string | null
    name?: StringWithAggregatesFilter<"Material"> | string
    unit?: StringWithAggregatesFilter<"Material"> | string
    minStock?: FloatWithAggregatesFilter<"Material"> | number
    currentStock?: FloatWithAggregatesFilter<"Material"> | number
    price?: FloatWithAggregatesFilter<"Material"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    companyId?: StringWithAggregatesFilter<"Material"> | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: FloatFilter<"InventoryMovement"> | number
    date?: DateTimeFilter<"InventoryMovement"> | Date | string
    description?: StringNullableFilter<"InventoryMovement"> | string | null
    materialId?: StringFilter<"InventoryMovement"> | string
    projectId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    companyId?: StringFilter<"InventoryMovement"> | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    materialId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    material?: MaterialOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: FloatFilter<"InventoryMovement"> | number
    date?: DateTimeFilter<"InventoryMovement"> | Date | string
    description?: StringNullableFilter<"InventoryMovement"> | string | null
    materialId?: StringFilter<"InventoryMovement"> | string
    projectId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    companyId?: StringFilter<"InventoryMovement"> | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    materialId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    type?: StringWithAggregatesFilter<"InventoryMovement"> | string
    quantity?: FloatWithAggregatesFilter<"InventoryMovement"> | number
    date?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
    description?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    materialId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    projectId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
    companyId?: StringWithAggregatesFilter<"InventoryMovement"> | string
  }

  export type ClientMonthlyInfoWhereInput = {
    AND?: ClientMonthlyInfoWhereInput | ClientMonthlyInfoWhereInput[]
    OR?: ClientMonthlyInfoWhereInput[]
    NOT?: ClientMonthlyInfoWhereInput | ClientMonthlyInfoWhereInput[]
    id?: StringFilter<"ClientMonthlyInfo"> | string
    clientId?: StringFilter<"ClientMonthlyInfo"> | string
    month?: IntFilter<"ClientMonthlyInfo"> | number
    year?: IntFilter<"ClientMonthlyInfo"> | number
    edpDate?: DateTimeNullableFilter<"ClientMonthlyInfo"> | Date | string | null
    createdAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    companyId?: StringFilter<"ClientMonthlyInfo"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ClientMonthlyInfoOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    edpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    client?: ClientOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ClientMonthlyInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_month_year?: ClientMonthlyInfoClientIdMonthYearCompoundUniqueInput
    AND?: ClientMonthlyInfoWhereInput | ClientMonthlyInfoWhereInput[]
    OR?: ClientMonthlyInfoWhereInput[]
    NOT?: ClientMonthlyInfoWhereInput | ClientMonthlyInfoWhereInput[]
    clientId?: StringFilter<"ClientMonthlyInfo"> | string
    month?: IntFilter<"ClientMonthlyInfo"> | number
    year?: IntFilter<"ClientMonthlyInfo"> | number
    edpDate?: DateTimeNullableFilter<"ClientMonthlyInfo"> | Date | string | null
    createdAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    companyId?: StringFilter<"ClientMonthlyInfo"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "clientId_month_year">

  export type ClientMonthlyInfoOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    edpDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ClientMonthlyInfoCountOrderByAggregateInput
    _avg?: ClientMonthlyInfoAvgOrderByAggregateInput
    _max?: ClientMonthlyInfoMaxOrderByAggregateInput
    _min?: ClientMonthlyInfoMinOrderByAggregateInput
    _sum?: ClientMonthlyInfoSumOrderByAggregateInput
  }

  export type ClientMonthlyInfoScalarWhereWithAggregatesInput = {
    AND?: ClientMonthlyInfoScalarWhereWithAggregatesInput | ClientMonthlyInfoScalarWhereWithAggregatesInput[]
    OR?: ClientMonthlyInfoScalarWhereWithAggregatesInput[]
    NOT?: ClientMonthlyInfoScalarWhereWithAggregatesInput | ClientMonthlyInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientMonthlyInfo"> | string
    clientId?: StringWithAggregatesFilter<"ClientMonthlyInfo"> | string
    month?: IntWithAggregatesFilter<"ClientMonthlyInfo"> | number
    year?: IntWithAggregatesFilter<"ClientMonthlyInfo"> | number
    edpDate?: DateTimeNullableWithAggregatesFilter<"ClientMonthlyInfo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientMonthlyInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientMonthlyInfo"> | Date | string
    companyId?: StringWithAggregatesFilter<"ClientMonthlyInfo"> | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    imageUrl?: StringFilter<"Plan"> | string
    projectId?: StringNullableFilter<"Plan"> | string | null
    costCenterId?: StringNullableFilter<"Plan"> | string | null
    stages?: IntFilter<"Plan"> | number
    systemType?: StringNullableFilter<"Plan"> | string | null
    installationType?: StringNullableFilter<"Plan"> | string | null
    installationDetail?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    companyId?: StringFilter<"Plan"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    marks?: PlanMarkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    projectId?: SortOrderInput | SortOrder
    costCenterId?: SortOrderInput | SortOrder
    stages?: SortOrder
    systemType?: SortOrderInput | SortOrder
    installationType?: SortOrderInput | SortOrder
    installationDetail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    costCenter?: CostCenterOrderByWithRelationInput
    marks?: PlanMarkOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    imageUrl?: StringFilter<"Plan"> | string
    projectId?: StringNullableFilter<"Plan"> | string | null
    costCenterId?: StringNullableFilter<"Plan"> | string | null
    stages?: IntFilter<"Plan"> | number
    systemType?: StringNullableFilter<"Plan"> | string | null
    installationType?: StringNullableFilter<"Plan"> | string | null
    installationDetail?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    companyId?: StringFilter<"Plan"> | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    costCenter?: XOR<CostCenterNullableScalarRelationFilter, CostCenterWhereInput> | null
    marks?: PlanMarkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    projectId?: SortOrderInput | SortOrder
    costCenterId?: SortOrderInput | SortOrder
    stages?: SortOrder
    systemType?: SortOrderInput | SortOrder
    installationType?: SortOrderInput | SortOrder
    installationDetail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    imageUrl?: StringWithAggregatesFilter<"Plan"> | string
    projectId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    costCenterId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    stages?: IntWithAggregatesFilter<"Plan"> | number
    systemType?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    installationType?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    installationDetail?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    companyId?: StringWithAggregatesFilter<"Plan"> | string
  }

  export type PlanMarkWhereInput = {
    AND?: PlanMarkWhereInput | PlanMarkWhereInput[]
    OR?: PlanMarkWhereInput[]
    NOT?: PlanMarkWhereInput | PlanMarkWhereInput[]
    id?: StringFilter<"PlanMark"> | string
    planId?: StringFilter<"PlanMark"> | string
    userId?: StringFilter<"PlanMark"> | string
    x?: FloatFilter<"PlanMark"> | number
    y?: FloatFilter<"PlanMark"> | number
    points?: JsonNullableFilter<"PlanMark">
    type?: StringFilter<"PlanMark"> | string
    date?: DateTimeFilter<"PlanMark"> | Date | string
    meters?: FloatFilter<"PlanMark"> | number
    comment?: StringNullableFilter<"PlanMark"> | string | null
    imageUrl?: StringNullableFilter<"PlanMark"> | string | null
    stage?: IntFilter<"PlanMark"> | number
    createdAt?: DateTimeFilter<"PlanMark"> | Date | string
    updatedAt?: DateTimeFilter<"PlanMark"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workers?: WorkerListRelationFilter
  }

  export type PlanMarkOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    points?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrder
    meters?: SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    stage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    workers?: WorkerOrderByRelationAggregateInput
  }

  export type PlanMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanMarkWhereInput | PlanMarkWhereInput[]
    OR?: PlanMarkWhereInput[]
    NOT?: PlanMarkWhereInput | PlanMarkWhereInput[]
    planId?: StringFilter<"PlanMark"> | string
    userId?: StringFilter<"PlanMark"> | string
    x?: FloatFilter<"PlanMark"> | number
    y?: FloatFilter<"PlanMark"> | number
    points?: JsonNullableFilter<"PlanMark">
    type?: StringFilter<"PlanMark"> | string
    date?: DateTimeFilter<"PlanMark"> | Date | string
    meters?: FloatFilter<"PlanMark"> | number
    comment?: StringNullableFilter<"PlanMark"> | string | null
    imageUrl?: StringNullableFilter<"PlanMark"> | string | null
    stage?: IntFilter<"PlanMark"> | number
    createdAt?: DateTimeFilter<"PlanMark"> | Date | string
    updatedAt?: DateTimeFilter<"PlanMark"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workers?: WorkerListRelationFilter
  }, "id">

  export type PlanMarkOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    points?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrder
    meters?: SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    stage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanMarkCountOrderByAggregateInput
    _avg?: PlanMarkAvgOrderByAggregateInput
    _max?: PlanMarkMaxOrderByAggregateInput
    _min?: PlanMarkMinOrderByAggregateInput
    _sum?: PlanMarkSumOrderByAggregateInput
  }

  export type PlanMarkScalarWhereWithAggregatesInput = {
    AND?: PlanMarkScalarWhereWithAggregatesInput | PlanMarkScalarWhereWithAggregatesInput[]
    OR?: PlanMarkScalarWhereWithAggregatesInput[]
    NOT?: PlanMarkScalarWhereWithAggregatesInput | PlanMarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanMark"> | string
    planId?: StringWithAggregatesFilter<"PlanMark"> | string
    userId?: StringWithAggregatesFilter<"PlanMark"> | string
    x?: FloatWithAggregatesFilter<"PlanMark"> | number
    y?: FloatWithAggregatesFilter<"PlanMark"> | number
    points?: JsonNullableWithAggregatesFilter<"PlanMark">
    type?: StringWithAggregatesFilter<"PlanMark"> | string
    date?: DateTimeWithAggregatesFilter<"PlanMark"> | Date | string
    meters?: FloatWithAggregatesFilter<"PlanMark"> | number
    comment?: StringNullableWithAggregatesFilter<"PlanMark"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"PlanMark"> | string | null
    stage?: IntWithAggregatesFilter<"PlanMark"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlanMark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanMark"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyCreateNestedManyWithoutUsersInput
    dailyReports?: DailyReportCreateNestedManyWithoutUserInput
    planMarks?: PlanMarkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUncheckedCreateNestedManyWithoutUsersInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutUserInput
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUpdateManyWithoutUsersNestedInput
    dailyReports?: DailyReportUpdateManyWithoutUserNestedInput
    planMarks?: PlanMarkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUncheckedUpdateManyWithoutUsersNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutUserNestedInput
    planMarks?: PlanMarkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CostCenterCreateInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutCostCenterInput
    plans?: PlanCreateNestedManyWithoutCostCenterInput
    company: CompanyCreateNestedOneWithoutCostCentersInput
  }

  export type CostCenterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCostCenterInput
    plans?: PlanUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutCostCenterNestedInput
    plans?: PlanUpdateManyWithoutCostCenterNestedInput
    company?: CompanyUpdateOneRequiredWithoutCostCentersNestedInput
  }

  export type CostCenterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCostCenterNestedInput
    plans?: PlanUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterCreateManyInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type CostCenterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerCreateInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewCreateNestedManyWithoutWorkersInput
    planMarks?: PlanMarkCreateNestedManyWithoutWorkersInput
    company: CompanyCreateNestedOneWithoutWorkersInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutWorkersInput
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUpdateManyWithoutWorkersNestedInput
    planMarks?: PlanMarkUpdateManyWithoutWorkersNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutWorkersNestedInput
    planMarks?: PlanMarkUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type WorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewCreateInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCrewsInput
    workers?: WorkerCreateNestedManyWithoutCrewsInput
    company: CompanyCreateNestedOneWithoutCrewsInput
  }

  export type CrewUncheckedCreateInput = {
    id?: string
    name: string
    role?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    workers?: WorkerUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type CrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    workers?: WorkerUpdateManyWithoutCrewsNestedInput
    company?: CompanyUpdateOneRequiredWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    workers?: WorkerUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type CrewCreateManyInput = {
    id?: string
    name: string
    role?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type CrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type JobTitleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutJobTitlesInput
  }

  export type JobTitleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type JobTitleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutJobTitlesNestedInput
  }

  export type JobTitleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobTitleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type JobTitleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    invoiceId: string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    invoiceId: string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportCreateInput = {
    id?: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyReportsInput
    project?: ProjectCreateNestedOneWithoutDailyReportsInput
    company: CompanyCreateNestedOneWithoutDailyReportInput
  }

  export type DailyReportUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DailyReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyReportsNestedInput
    project?: ProjectUpdateOneWithoutDailyReportsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyReportNestedInput
  }

  export type DailyReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DailyReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    purchaseOrderId: string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    purchaseOrderId: string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    createdAt?: Date | string
    status?: string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentRequirementCreateInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementsInput
    documents?: DocumentCreateNestedManyWithoutRequirementInput
    company: CompanyCreateNestedOneWithoutRequirementsInput
  }

  export type DocumentRequirementUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    documents?: DocumentUpdateManyWithoutRequirementNestedInput
    company?: CompanyUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type DocumentRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialCreateInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutMaterialInput
    company: CompanyCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutMaterialNestedInput
    company?: CompanyUpdateOneRequiredWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutMovementsInput
    project?: ProjectCreateNestedOneWithoutInventoryMovementsInput
    company: CompanyCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    projectId?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMovementsNestedInput
    project?: ProjectUpdateOneWithoutInventoryMovementsNestedInput
    company?: CompanyUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    projectId?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientMonthlyInfoCreateInput = {
    id?: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMonthlyInfoInput
    company: CompanyCreateNestedOneWithoutMonthlyInfoInput
  }

  export type ClientMonthlyInfoUncheckedCreateInput = {
    id?: string
    clientId: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ClientMonthlyInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMonthlyInfoNestedInput
    company?: CompanyUpdateOneRequiredWithoutMonthlyInfoNestedInput
  }

  export type ClientMonthlyInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientMonthlyInfoCreateManyInput = {
    id?: string
    clientId: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ClientMonthlyInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMonthlyInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    imageUrl: string
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPlansInput
    costCenter?: CostCenterCreateNestedOneWithoutPlansInput
    marks?: PlanMarkCreateNestedManyWithoutPlanInput
    company: CompanyCreateNestedOneWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    marks?: PlanMarkUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPlansNestedInput
    costCenter?: CostCenterUpdateOneWithoutPlansNestedInput
    marks?: PlanMarkUpdateManyWithoutPlanNestedInput
    company?: CompanyUpdateOneRequiredWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    marks?: PlanMarkUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanMarkCreateInput = {
    id?: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutMarksInput
    user: UserCreateNestedOneWithoutPlanMarksInput
    workers?: WorkerCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkUncheckedCreateInput = {
    id?: string
    planId: string
    userId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: WorkerUncheckedCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutMarksNestedInput
    user?: UserUpdateOneRequiredWithoutPlanMarksNestedInput
    workers?: WorkerUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUncheckedUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkCreateManyInput = {
    id?: string
    planId: string
    userId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type DailyReportListRelationFilter = {
    every?: DailyReportWhereInput
    some?: DailyReportWhereInput
    none?: DailyReportWhereInput
  }

  export type PlanMarkListRelationFilter = {
    every?: PlanMarkWhereInput
    some?: PlanMarkWhereInput
    none?: PlanMarkWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    allowedSections?: SortOrder
    assignedProjectIds?: SortOrder
    activeCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    activeCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    activeCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentRequirementListRelationFilter = {
    every?: DocumentRequirementWhereInput
    some?: DocumentRequirementWhereInput
    none?: DocumentRequirementWhereInput
  }

  export type ClientMonthlyInfoListRelationFilter = {
    every?: ClientMonthlyInfoWhereInput
    some?: ClientMonthlyInfoWhereInput
    none?: ClientMonthlyInfoWhereInput
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type CostCenterListRelationFilter = {
    every?: CostCenterWhereInput
    some?: CostCenterWhereInput
    none?: CostCenterWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type JobTitleListRelationFilter = {
    every?: JobTitleWhereInput
    some?: JobTitleWhereInput
    none?: JobTitleWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientMonthlyInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostCenterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type ClientRutCompanyIdCompoundUniqueInput = {
    rut: string
    companyId: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    progress?: SortOrder
    budget?: SortOrder
    address?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workerIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    progress?: SortOrder
    budget?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    progress?: SortOrder
    budget?: SortOrder
    address?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    progress?: SortOrder
    budget?: SortOrder
    address?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    progress?: SortOrder
    budget?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CostCenterCodeCompanyIdCompoundUniqueInput = {
    code: string
    companyId: string
  }

  export type CostCenterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    budget?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CostCenterAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type CostCenterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    budget?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CostCenterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    budget?: SortOrder
    createAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CostCenterSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WorkerRutCompanyIdCompoundUniqueInput = {
    rut: string
    companyId: string
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    role?: SortOrder
    specialty?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    experienceYears?: SortOrder
    certifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkerAvgOrderByAggregateInput = {
    experienceYears?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    role?: SortOrder
    specialty?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    experienceYears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    rut?: SortOrder
    name?: SortOrder
    role?: SortOrder
    specialty?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    experienceYears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkerSumOrderByAggregateInput = {
    experienceYears?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type JobTitleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type JobTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type JobTitleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CostCenterNullableScalarRelationFilter = {
    is?: CostCenterWhereInput | null
    isNot?: CostCenterWhereInput | null
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    type?: SortOrder
    emissionType?: SortOrder
    purchaseOrderNumber?: SortOrder
    dispatchGuideNumber?: SortOrder
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    relatedInvoiceId?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    type?: SortOrder
    emissionType?: SortOrder
    purchaseOrderNumber?: SortOrder
    dispatchGuideNumber?: SortOrder
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    relatedInvoiceId?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    type?: SortOrder
    emissionType?: SortOrder
    purchaseOrderNumber?: SortOrder
    dispatchGuideNumber?: SortOrder
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    relatedInvoiceId?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    netAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoiceId?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DailyReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DailyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DailyReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderNumberCompanyIdCompoundUniqueInput = {
    number: string
    companyId: string
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    provider?: SortOrder
    date?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    provider?: SortOrder
    date?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    provider?: SortOrder
    date?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type DocumentRequirementNullableScalarRelationFilter = {
    is?: DocumentRequirementWhereInput | null
    isNot?: DocumentRequirementWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    requirementId?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    requirementId?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    projectId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    requirementId?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type DocumentRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    month?: SortOrder
    year?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DocumentRequirementAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type DocumentRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    month?: SortOrder
    year?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DocumentRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    month?: SortOrder
    year?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DocumentRequirementSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type MaterialCodeCompanyIdCompoundUniqueInput = {
    code: string
    companyId: string
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    minStock?: SortOrder
    currentStock?: SortOrder
    price?: SortOrder
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ClientMonthlyInfoClientIdMonthYearCompoundUniqueInput = {
    clientId: string
    month: number
    year: number
  }

  export type ClientMonthlyInfoCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    edpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ClientMonthlyInfoAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type ClientMonthlyInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    edpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ClientMonthlyInfoMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    edpDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ClientMonthlyInfoSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    stages?: SortOrder
    systemType?: SortOrder
    installationType?: SortOrder
    installationDetail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    stages?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    stages?: SortOrder
    systemType?: SortOrder
    installationType?: SortOrder
    installationDetail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    projectId?: SortOrder
    costCenterId?: SortOrder
    stages?: SortOrder
    systemType?: SortOrder
    installationType?: SortOrder
    installationDetail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    stages?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type PlanMarkCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    points?: SortOrder
    type?: SortOrder
    date?: SortOrder
    meters?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    stage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMarkAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    meters?: SortOrder
    stage?: SortOrder
  }

  export type PlanMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    type?: SortOrder
    date?: SortOrder
    meters?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    stage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMarkMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    type?: SortOrder
    date?: SortOrder
    meters?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    stage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMarkSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    meters?: SortOrder
    stage?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserCreateallowedSectionsInput = {
    set: string[]
  }

  export type UserCreateassignedProjectIdsInput = {
    set: string[]
  }

  export type CompanyCreateNestedManyWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput> | CompanyCreateWithoutUsersInput[] | CompanyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput | CompanyCreateOrConnectWithoutUsersInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type DailyReportCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput> | DailyReportCreateWithoutUserInput[] | DailyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutUserInput | DailyReportCreateOrConnectWithoutUserInput[]
    createMany?: DailyReportCreateManyUserInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type PlanMarkCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput> | PlanMarkCreateWithoutUserInput[] | PlanMarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutUserInput | PlanMarkCreateOrConnectWithoutUserInput[]
    createMany?: PlanMarkCreateManyUserInputEnvelope
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput> | CompanyCreateWithoutUsersInput[] | CompanyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput | CompanyCreateOrConnectWithoutUsersInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type DailyReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput> | DailyReportCreateWithoutUserInput[] | DailyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutUserInput | DailyReportCreateOrConnectWithoutUserInput[]
    createMany?: DailyReportCreateManyUserInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type PlanMarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput> | PlanMarkCreateWithoutUserInput[] | PlanMarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutUserInput | PlanMarkCreateOrConnectWithoutUserInput[]
    createMany?: PlanMarkCreateManyUserInputEnvelope
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateallowedSectionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateassignedProjectIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput> | CompanyCreateWithoutUsersInput[] | CompanyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput | CompanyCreateOrConnectWithoutUsersInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUsersInput | CompanyUpsertWithWhereUniqueWithoutUsersInput[]
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUsersInput | CompanyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUsersInput | CompanyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type DailyReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput> | DailyReportCreateWithoutUserInput[] | DailyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutUserInput | DailyReportCreateOrConnectWithoutUserInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutUserInput | DailyReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyReportCreateManyUserInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutUserInput | DailyReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutUserInput | DailyReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type PlanMarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput> | PlanMarkCreateWithoutUserInput[] | PlanMarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutUserInput | PlanMarkCreateOrConnectWithoutUserInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutUserInput | PlanMarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanMarkCreateManyUserInputEnvelope
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutUserInput | PlanMarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutUserInput | PlanMarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput> | CompanyCreateWithoutUsersInput[] | CompanyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput | CompanyCreateOrConnectWithoutUsersInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUsersInput | CompanyUpsertWithWhereUniqueWithoutUsersInput[]
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUsersInput | CompanyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUsersInput | CompanyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type DailyReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput> | DailyReportCreateWithoutUserInput[] | DailyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutUserInput | DailyReportCreateOrConnectWithoutUserInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutUserInput | DailyReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyReportCreateManyUserInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutUserInput | DailyReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutUserInput | DailyReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type PlanMarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput> | PlanMarkCreateWithoutUserInput[] | PlanMarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutUserInput | PlanMarkCreateOrConnectWithoutUserInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutUserInput | PlanMarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanMarkCreateManyUserInputEnvelope
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutUserInput | PlanMarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutUserInput | PlanMarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput> | UserCreateWithoutCompaniesInput[] | UserUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput | UserCreateOrConnectWithoutCompaniesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRequirementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput> | DocumentRequirementCreateWithoutCompanyInput[] | DocumentRequirementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutCompanyInput | DocumentRequirementCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentRequirementCreateManyCompanyInputEnvelope
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
  }

  export type ClientMonthlyInfoCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput> | ClientMonthlyInfoCreateWithoutCompanyInput[] | ClientMonthlyInfoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutCompanyInput | ClientMonthlyInfoCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientMonthlyInfoCreateManyCompanyInputEnvelope
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
  }

  export type WorkerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type CrewCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput> | CrewCreateWithoutCompanyInput[] | CrewUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCompanyInput | CrewCreateOrConnectWithoutCompanyInput[]
    createMany?: CrewCreateManyCompanyInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput> | InventoryMovementCreateWithoutCompanyInput[] | InventoryMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCompanyInput | InventoryMovementCreateOrConnectWithoutCompanyInput[]
    createMany?: InventoryMovementCreateManyCompanyInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type CostCenterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
  }

  export type DailyReportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput> | DailyReportCreateWithoutCompanyInput[] | DailyReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutCompanyInput | DailyReportCreateOrConnectWithoutCompanyInput[]
    createMany?: DailyReportCreateManyCompanyInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput> | MaterialCreateWithoutCompanyInput[] | MaterialUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCompanyInput | MaterialCreateOrConnectWithoutCompanyInput[]
    createMany?: MaterialCreateManyCompanyInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PlanCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput> | PlanCreateWithoutCompanyInput[] | PlanUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput | PlanCreateOrConnectWithoutCompanyInput[]
    createMany?: PlanCreateManyCompanyInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type JobTitleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput> | JobTitleCreateWithoutCompanyInput[] | JobTitleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobTitleCreateOrConnectWithoutCompanyInput | JobTitleCreateOrConnectWithoutCompanyInput[]
    createMany?: JobTitleCreateManyCompanyInputEnvelope
    connect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput> | UserCreateWithoutCompaniesInput[] | UserUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput | UserCreateOrConnectWithoutCompaniesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput> | DocumentRequirementCreateWithoutCompanyInput[] | DocumentRequirementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutCompanyInput | DocumentRequirementCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentRequirementCreateManyCompanyInputEnvelope
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
  }

  export type ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput> | ClientMonthlyInfoCreateWithoutCompanyInput[] | ClientMonthlyInfoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutCompanyInput | ClientMonthlyInfoCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientMonthlyInfoCreateManyCompanyInputEnvelope
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput> | CrewCreateWithoutCompanyInput[] | CrewUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCompanyInput | CrewCreateOrConnectWithoutCompanyInput[]
    createMany?: CrewCreateManyCompanyInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput> | InventoryMovementCreateWithoutCompanyInput[] | InventoryMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCompanyInput | InventoryMovementCreateOrConnectWithoutCompanyInput[]
    createMany?: InventoryMovementCreateManyCompanyInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type CostCenterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
  }

  export type DailyReportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput> | DailyReportCreateWithoutCompanyInput[] | DailyReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutCompanyInput | DailyReportCreateOrConnectWithoutCompanyInput[]
    createMany?: DailyReportCreateManyCompanyInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput> | MaterialCreateWithoutCompanyInput[] | MaterialUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCompanyInput | MaterialCreateOrConnectWithoutCompanyInput[]
    createMany?: MaterialCreateManyCompanyInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput> | PlanCreateWithoutCompanyInput[] | PlanUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput | PlanCreateOrConnectWithoutCompanyInput[]
    createMany?: PlanCreateManyCompanyInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type JobTitleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput> | JobTitleCreateWithoutCompanyInput[] | JobTitleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobTitleCreateOrConnectWithoutCompanyInput | JobTitleCreateOrConnectWithoutCompanyInput[]
    createMany?: JobTitleCreateManyCompanyInputEnvelope
    connect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput> | UserCreateWithoutCompaniesInput[] | UserUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput | UserCreateOrConnectWithoutCompaniesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompaniesInput | UserUpsertWithWhereUniqueWithoutCompaniesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompaniesInput | UserUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompaniesInput | UserUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCompanyInput | ClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCompanyInput | ClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCompanyInput | ClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompanyInput | ProjectUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompanyInput | ProjectUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompanyInput | ProjectUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRequirementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput> | DocumentRequirementCreateWithoutCompanyInput[] | DocumentRequirementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutCompanyInput | DocumentRequirementCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentRequirementUpsertWithWhereUniqueWithoutCompanyInput | DocumentRequirementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentRequirementCreateManyCompanyInputEnvelope
    set?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    disconnect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    delete?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    update?: DocumentRequirementUpdateWithWhereUniqueWithoutCompanyInput | DocumentRequirementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentRequirementUpdateManyWithWhereWithoutCompanyInput | DocumentRequirementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
  }

  export type ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput> | ClientMonthlyInfoCreateWithoutCompanyInput[] | ClientMonthlyInfoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutCompanyInput | ClientMonthlyInfoCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientMonthlyInfoUpsertWithWhereUniqueWithoutCompanyInput | ClientMonthlyInfoUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientMonthlyInfoCreateManyCompanyInputEnvelope
    set?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    disconnect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    delete?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    update?: ClientMonthlyInfoUpdateWithWhereUniqueWithoutCompanyInput | ClientMonthlyInfoUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientMonthlyInfoUpdateManyWithWhereWithoutCompanyInput | ClientMonthlyInfoUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
  }

  export type WorkerUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCompanyInput | WorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCompanyInput | WorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCompanyInput | WorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type CrewUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput> | CrewCreateWithoutCompanyInput[] | CrewUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCompanyInput | CrewCreateOrConnectWithoutCompanyInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCompanyInput | CrewUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CrewCreateManyCompanyInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCompanyInput | CrewUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCompanyInput | CrewUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput> | InventoryMovementCreateWithoutCompanyInput[] | InventoryMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCompanyInput | InventoryMovementCreateOrConnectWithoutCompanyInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutCompanyInput | InventoryMovementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InventoryMovementCreateManyCompanyInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutCompanyInput | InventoryMovementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutCompanyInput | InventoryMovementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type CostCenterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    upsert?: CostCenterUpsertWithWhereUniqueWithoutCompanyInput | CostCenterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    set?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    disconnect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    delete?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    update?: CostCenterUpdateWithWhereUniqueWithoutCompanyInput | CostCenterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CostCenterUpdateManyWithWhereWithoutCompanyInput | CostCenterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
  }

  export type DailyReportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput> | DailyReportCreateWithoutCompanyInput[] | DailyReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutCompanyInput | DailyReportCreateOrConnectWithoutCompanyInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutCompanyInput | DailyReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DailyReportCreateManyCompanyInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutCompanyInput | DailyReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutCompanyInput | DailyReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput> | MaterialCreateWithoutCompanyInput[] | MaterialUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCompanyInput | MaterialCreateOrConnectWithoutCompanyInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCompanyInput | MaterialUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MaterialCreateManyCompanyInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCompanyInput | MaterialUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCompanyInput | MaterialUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PlanUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput> | PlanCreateWithoutCompanyInput[] | PlanUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput | PlanCreateOrConnectWithoutCompanyInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutCompanyInput | PlanUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PlanCreateManyCompanyInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutCompanyInput | PlanUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutCompanyInput | PlanUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type JobTitleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput> | JobTitleCreateWithoutCompanyInput[] | JobTitleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobTitleCreateOrConnectWithoutCompanyInput | JobTitleCreateOrConnectWithoutCompanyInput[]
    upsert?: JobTitleUpsertWithWhereUniqueWithoutCompanyInput | JobTitleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobTitleCreateManyCompanyInputEnvelope
    set?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    disconnect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    delete?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    connect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    update?: JobTitleUpdateWithWhereUniqueWithoutCompanyInput | JobTitleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobTitleUpdateManyWithWhereWithoutCompanyInput | JobTitleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobTitleScalarWhereInput | JobTitleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput> | UserCreateWithoutCompaniesInput[] | UserUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput | UserCreateOrConnectWithoutCompaniesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompaniesInput | UserUpsertWithWhereUniqueWithoutCompaniesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompaniesInput | UserUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompaniesInput | UserUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCompanyInput | ClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCompanyInput | ClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCompanyInput | ClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput> | ProjectCreateWithoutCompanyInput[] | ProjectUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompanyInput | ProjectCreateOrConnectWithoutCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompanyInput | ProjectUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ProjectCreateManyCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompanyInput | ProjectUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompanyInput | ProjectUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput> | DocumentRequirementCreateWithoutCompanyInput[] | DocumentRequirementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutCompanyInput | DocumentRequirementCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentRequirementUpsertWithWhereUniqueWithoutCompanyInput | DocumentRequirementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentRequirementCreateManyCompanyInputEnvelope
    set?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    disconnect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    delete?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    update?: DocumentRequirementUpdateWithWhereUniqueWithoutCompanyInput | DocumentRequirementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentRequirementUpdateManyWithWhereWithoutCompanyInput | DocumentRequirementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
  }

  export type ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput> | ClientMonthlyInfoCreateWithoutCompanyInput[] | ClientMonthlyInfoUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutCompanyInput | ClientMonthlyInfoCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientMonthlyInfoUpsertWithWhereUniqueWithoutCompanyInput | ClientMonthlyInfoUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientMonthlyInfoCreateManyCompanyInputEnvelope
    set?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    disconnect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    delete?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    update?: ClientMonthlyInfoUpdateWithWhereUniqueWithoutCompanyInput | ClientMonthlyInfoUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientMonthlyInfoUpdateManyWithWhereWithoutCompanyInput | ClientMonthlyInfoUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCompanyInput | WorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCompanyInput | WorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCompanyInput | WorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput> | CrewCreateWithoutCompanyInput[] | CrewUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCompanyInput | CrewCreateOrConnectWithoutCompanyInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCompanyInput | CrewUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CrewCreateManyCompanyInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCompanyInput | CrewUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCompanyInput | CrewUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput> | InventoryMovementCreateWithoutCompanyInput[] | InventoryMovementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutCompanyInput | InventoryMovementCreateOrConnectWithoutCompanyInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutCompanyInput | InventoryMovementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InventoryMovementCreateManyCompanyInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutCompanyInput | InventoryMovementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutCompanyInput | InventoryMovementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type CostCenterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput> | CostCenterCreateWithoutCompanyInput[] | CostCenterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CostCenterCreateOrConnectWithoutCompanyInput | CostCenterCreateOrConnectWithoutCompanyInput[]
    upsert?: CostCenterUpsertWithWhereUniqueWithoutCompanyInput | CostCenterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CostCenterCreateManyCompanyInputEnvelope
    set?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    disconnect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    delete?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    connect?: CostCenterWhereUniqueInput | CostCenterWhereUniqueInput[]
    update?: CostCenterUpdateWithWhereUniqueWithoutCompanyInput | CostCenterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CostCenterUpdateManyWithWhereWithoutCompanyInput | CostCenterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
  }

  export type DailyReportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput> | DailyReportCreateWithoutCompanyInput[] | DailyReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutCompanyInput | DailyReportCreateOrConnectWithoutCompanyInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutCompanyInput | DailyReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DailyReportCreateManyCompanyInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutCompanyInput | DailyReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutCompanyInput | DailyReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput> | MaterialCreateWithoutCompanyInput[] | MaterialUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCompanyInput | MaterialCreateOrConnectWithoutCompanyInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCompanyInput | MaterialUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MaterialCreateManyCompanyInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCompanyInput | MaterialUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCompanyInput | MaterialUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput> | PlanCreateWithoutCompanyInput[] | PlanUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput | PlanCreateOrConnectWithoutCompanyInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutCompanyInput | PlanUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PlanCreateManyCompanyInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutCompanyInput | PlanUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutCompanyInput | PlanUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type JobTitleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput> | JobTitleCreateWithoutCompanyInput[] | JobTitleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobTitleCreateOrConnectWithoutCompanyInput | JobTitleCreateOrConnectWithoutCompanyInput[]
    upsert?: JobTitleUpsertWithWhereUniqueWithoutCompanyInput | JobTitleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobTitleCreateManyCompanyInputEnvelope
    set?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    disconnect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    delete?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    connect?: JobTitleWhereUniqueInput | JobTitleWhereUniqueInput[]
    update?: JobTitleUpdateWithWhereUniqueWithoutCompanyInput | JobTitleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobTitleUpdateManyWithWhereWithoutCompanyInput | JobTitleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobTitleScalarWhereInput | JobTitleScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRequirementCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput> | DocumentRequirementCreateWithoutClientInput[] | DocumentRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutClientInput | DocumentRequirementCreateOrConnectWithoutClientInput[]
    createMany?: DocumentRequirementCreateManyClientInputEnvelope
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
  }

  export type ClientMonthlyInfoCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput> | ClientMonthlyInfoCreateWithoutClientInput[] | ClientMonthlyInfoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutClientInput | ClientMonthlyInfoCreateOrConnectWithoutClientInput[]
    createMany?: ClientMonthlyInfoCreateManyClientInputEnvelope
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutClientsInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRequirementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput> | DocumentRequirementCreateWithoutClientInput[] | DocumentRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutClientInput | DocumentRequirementCreateOrConnectWithoutClientInput[]
    createMany?: DocumentRequirementCreateManyClientInputEnvelope
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
  }

  export type ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput> | ClientMonthlyInfoCreateWithoutClientInput[] | ClientMonthlyInfoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutClientInput | ClientMonthlyInfoCreateOrConnectWithoutClientInput[]
    createMany?: ClientMonthlyInfoCreateManyClientInputEnvelope
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRequirementUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput> | DocumentRequirementCreateWithoutClientInput[] | DocumentRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutClientInput | DocumentRequirementCreateOrConnectWithoutClientInput[]
    upsert?: DocumentRequirementUpsertWithWhereUniqueWithoutClientInput | DocumentRequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentRequirementCreateManyClientInputEnvelope
    set?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    disconnect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    delete?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    update?: DocumentRequirementUpdateWithWhereUniqueWithoutClientInput | DocumentRequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentRequirementUpdateManyWithWhereWithoutClientInput | DocumentRequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
  }

  export type ClientMonthlyInfoUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput> | ClientMonthlyInfoCreateWithoutClientInput[] | ClientMonthlyInfoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutClientInput | ClientMonthlyInfoCreateOrConnectWithoutClientInput[]
    upsert?: ClientMonthlyInfoUpsertWithWhereUniqueWithoutClientInput | ClientMonthlyInfoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientMonthlyInfoCreateManyClientInputEnvelope
    set?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    disconnect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    delete?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    update?: ClientMonthlyInfoUpdateWithWhereUniqueWithoutClientInput | ClientMonthlyInfoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientMonthlyInfoUpdateManyWithWhereWithoutClientInput | ClientMonthlyInfoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    upsert?: CompanyUpsertWithoutClientsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutClientsInput, CompanyUpdateWithoutClientsInput>, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput> | DocumentRequirementCreateWithoutClientInput[] | DocumentRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutClientInput | DocumentRequirementCreateOrConnectWithoutClientInput[]
    upsert?: DocumentRequirementUpsertWithWhereUniqueWithoutClientInput | DocumentRequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentRequirementCreateManyClientInputEnvelope
    set?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    disconnect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    delete?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    connect?: DocumentRequirementWhereUniqueInput | DocumentRequirementWhereUniqueInput[]
    update?: DocumentRequirementUpdateWithWhereUniqueWithoutClientInput | DocumentRequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentRequirementUpdateManyWithWhereWithoutClientInput | DocumentRequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
  }

  export type ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput> | ClientMonthlyInfoCreateWithoutClientInput[] | ClientMonthlyInfoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMonthlyInfoCreateOrConnectWithoutClientInput | ClientMonthlyInfoCreateOrConnectWithoutClientInput[]
    upsert?: ClientMonthlyInfoUpsertWithWhereUniqueWithoutClientInput | ClientMonthlyInfoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientMonthlyInfoCreateManyClientInputEnvelope
    set?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    disconnect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    delete?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    connect?: ClientMonthlyInfoWhereUniqueInput | ClientMonthlyInfoWhereUniqueInput[]
    update?: ClientMonthlyInfoUpdateWithWhereUniqueWithoutClientInput | ClientMonthlyInfoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientMonthlyInfoUpdateManyWithWhereWithoutClientInput | ClientMonthlyInfoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
  }

  export type ProjectCreateworkerIdsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    connect?: ClientWhereUniqueInput
  }

  export type CrewCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutProjectInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DailyReportCreateNestedManyWithoutProjectInput = {
    create?: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput> | DailyReportCreateWithoutProjectInput[] | DailyReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutProjectInput | DailyReportCreateOrConnectWithoutProjectInput[]
    createMany?: DailyReportCreateManyProjectInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput> | InventoryMovementCreateWithoutProjectInput[] | InventoryMovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProjectInput | InventoryMovementCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryMovementCreateManyProjectInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type PlanCreateNestedManyWithoutProjectInput = {
    create?: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput> | PlanCreateWithoutProjectInput[] | PlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutProjectInput | PlanCreateOrConnectWithoutProjectInput[]
    createMany?: PlanCreateManyProjectInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProjectsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CrewUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DailyReportUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput> | DailyReportCreateWithoutProjectInput[] | DailyReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutProjectInput | DailyReportCreateOrConnectWithoutProjectInput[]
    createMany?: DailyReportCreateManyProjectInputEnvelope
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput> | InventoryMovementCreateWithoutProjectInput[] | InventoryMovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProjectInput | InventoryMovementCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryMovementCreateManyProjectInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput> | PlanCreateWithoutProjectInput[] | PlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutProjectInput | PlanCreateOrConnectWithoutProjectInput[]
    createMany?: PlanCreateManyProjectInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdateworkerIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    upsert?: ClientUpsertWithoutProjectsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjectsInput, ClientUpdateWithoutProjectsInput>, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type CrewUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutProjectInput | CrewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutProjectInput | CrewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutProjectInput | CrewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutProjectInput | InvoiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutProjectInput | InvoiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutProjectInput | InvoiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DailyReportUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput> | DailyReportCreateWithoutProjectInput[] | DailyReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutProjectInput | DailyReportCreateOrConnectWithoutProjectInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutProjectInput | DailyReportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DailyReportCreateManyProjectInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutProjectInput | DailyReportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutProjectInput | DailyReportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput | PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput | PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutProjectInput | PurchaseOrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput> | InventoryMovementCreateWithoutProjectInput[] | InventoryMovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProjectInput | InventoryMovementCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProjectInput | InventoryMovementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryMovementCreateManyProjectInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProjectInput | InventoryMovementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProjectInput | InventoryMovementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type PlanUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput> | PlanCreateWithoutProjectInput[] | PlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutProjectInput | PlanCreateOrConnectWithoutProjectInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutProjectInput | PlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PlanCreateManyProjectInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutProjectInput | PlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutProjectInput | PlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProjectsInput
    upsert?: CompanyUpsertWithoutProjectsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProjectsInput, CompanyUpdateWithoutProjectsInput>, CompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type CrewUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput> | CrewCreateWithoutProjectInput[] | CrewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutProjectInput | CrewCreateOrConnectWithoutProjectInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutProjectInput | CrewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrewCreateManyProjectInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutProjectInput | CrewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutProjectInput | CrewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutProjectInput | InvoiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutProjectInput | InvoiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutProjectInput | InvoiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DailyReportUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput> | DailyReportCreateWithoutProjectInput[] | DailyReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DailyReportCreateOrConnectWithoutProjectInput | DailyReportCreateOrConnectWithoutProjectInput[]
    upsert?: DailyReportUpsertWithWhereUniqueWithoutProjectInput | DailyReportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DailyReportCreateManyProjectInputEnvelope
    set?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    disconnect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    delete?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    connect?: DailyReportWhereUniqueInput | DailyReportWhereUniqueInput[]
    update?: DailyReportUpdateWithWhereUniqueWithoutProjectInput | DailyReportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DailyReportUpdateManyWithWhereWithoutProjectInput | DailyReportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput> | PurchaseOrderCreateWithoutProjectInput[] | PurchaseOrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutProjectInput | PurchaseOrderCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput | PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseOrderCreateManyProjectInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput | PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutProjectInput | PurchaseOrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput> | InventoryMovementCreateWithoutProjectInput[] | InventoryMovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProjectInput | InventoryMovementCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProjectInput | InventoryMovementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryMovementCreateManyProjectInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProjectInput | InventoryMovementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProjectInput | InventoryMovementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput> | PlanCreateWithoutProjectInput[] | PlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutProjectInput | PlanCreateOrConnectWithoutProjectInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutProjectInput | PlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PlanCreateManyProjectInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutProjectInput | PlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutProjectInput | PlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput> | InvoiceCreateWithoutCostCenterInput[] | InvoiceUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCostCenterInput | InvoiceCreateOrConnectWithoutCostCenterInput[]
    createMany?: InvoiceCreateManyCostCenterInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PlanCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput> | PlanCreateWithoutCostCenterInput[] | PlanUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCostCenterInput | PlanCreateOrConnectWithoutCostCenterInput[]
    createMany?: PlanCreateManyCostCenterInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutCostCentersInput = {
    create?: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCostCentersInput
    connect?: CompanyWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput> | InvoiceCreateWithoutCostCenterInput[] | InvoiceUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCostCenterInput | InvoiceCreateOrConnectWithoutCostCenterInput[]
    createMany?: InvoiceCreateManyCostCenterInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutCostCenterInput = {
    create?: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput> | PlanCreateWithoutCostCenterInput[] | PlanUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCostCenterInput | PlanCreateOrConnectWithoutCostCenterInput[]
    createMany?: PlanCreateManyCostCenterInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type InvoiceUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput> | InvoiceCreateWithoutCostCenterInput[] | InvoiceUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCostCenterInput | InvoiceCreateOrConnectWithoutCostCenterInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCostCenterInput | InvoiceUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: InvoiceCreateManyCostCenterInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCostCenterInput | InvoiceUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCostCenterInput | InvoiceUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PlanUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput> | PlanCreateWithoutCostCenterInput[] | PlanUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCostCenterInput | PlanCreateOrConnectWithoutCostCenterInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutCostCenterInput | PlanUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: PlanCreateManyCostCenterInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutCostCenterInput | PlanUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutCostCenterInput | PlanUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutCostCentersNestedInput = {
    create?: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCostCentersInput
    upsert?: CompanyUpsertWithoutCostCentersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCostCentersInput, CompanyUpdateWithoutCostCentersInput>, CompanyUncheckedUpdateWithoutCostCentersInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput> | InvoiceCreateWithoutCostCenterInput[] | InvoiceUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCostCenterInput | InvoiceCreateOrConnectWithoutCostCenterInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCostCenterInput | InvoiceUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: InvoiceCreateManyCostCenterInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCostCenterInput | InvoiceUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCostCenterInput | InvoiceUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutCostCenterNestedInput = {
    create?: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput> | PlanCreateWithoutCostCenterInput[] | PlanUncheckedCreateWithoutCostCenterInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutCostCenterInput | PlanCreateOrConnectWithoutCostCenterInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutCostCenterInput | PlanUpsertWithWhereUniqueWithoutCostCenterInput[]
    createMany?: PlanCreateManyCostCenterInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutCostCenterInput | PlanUpdateWithWhereUniqueWithoutCostCenterInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutCostCenterInput | PlanUpdateManyWithWhereWithoutCostCenterInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type WorkerCreatecertificationsInput = {
    set: string[]
  }

  export type CrewCreateNestedManyWithoutWorkersInput = {
    create?: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput> | CrewCreateWithoutWorkersInput[] | CrewUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutWorkersInput | CrewCreateOrConnectWithoutWorkersInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type PlanMarkCreateNestedManyWithoutWorkersInput = {
    create?: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput> | PlanMarkCreateWithoutWorkersInput[] | PlanMarkUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutWorkersInput | PlanMarkCreateOrConnectWithoutWorkersInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWorkersInput = {
    create?: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CrewUncheckedCreateNestedManyWithoutWorkersInput = {
    create?: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput> | CrewCreateWithoutWorkersInput[] | CrewUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutWorkersInput | CrewCreateOrConnectWithoutWorkersInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type PlanMarkUncheckedCreateNestedManyWithoutWorkersInput = {
    create?: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput> | PlanMarkCreateWithoutWorkersInput[] | PlanMarkUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutWorkersInput | PlanMarkCreateOrConnectWithoutWorkersInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkerUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CrewUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput> | CrewCreateWithoutWorkersInput[] | CrewUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutWorkersInput | CrewCreateOrConnectWithoutWorkersInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutWorkersInput | CrewUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutWorkersInput | CrewUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutWorkersInput | CrewUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type PlanMarkUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput> | PlanMarkCreateWithoutWorkersInput[] | PlanMarkUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutWorkersInput | PlanMarkCreateOrConnectWithoutWorkersInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutWorkersInput | PlanMarkUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutWorkersInput | PlanMarkUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutWorkersInput | PlanMarkUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWorkersNestedInput = {
    create?: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkersInput
    upsert?: CompanyUpsertWithoutWorkersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWorkersInput, CompanyUpdateWithoutWorkersInput>, CompanyUncheckedUpdateWithoutWorkersInput>
  }

  export type CrewUncheckedUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput> | CrewCreateWithoutWorkersInput[] | CrewUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutWorkersInput | CrewCreateOrConnectWithoutWorkersInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutWorkersInput | CrewUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutWorkersInput | CrewUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutWorkersInput | CrewUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type PlanMarkUncheckedUpdateManyWithoutWorkersNestedInput = {
    create?: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput> | PlanMarkCreateWithoutWorkersInput[] | PlanMarkUncheckedCreateWithoutWorkersInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutWorkersInput | PlanMarkCreateOrConnectWithoutWorkersInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutWorkersInput | PlanMarkUpsertWithWhereUniqueWithoutWorkersInput[]
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutWorkersInput | PlanMarkUpdateWithWhereUniqueWithoutWorkersInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutWorkersInput | PlanMarkUpdateManyWithWhereWithoutWorkersInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutCrewsInput = {
    create?: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrewsInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkerCreateNestedManyWithoutCrewsInput = {
    create?: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput> | WorkerCreateWithoutCrewsInput[] | WorkerUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewsInput | WorkerCreateOrConnectWithoutCrewsInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutCrewsInput = {
    create?: XOR<CompanyCreateWithoutCrewsInput, CompanyUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCrewsInput
    connect?: CompanyWhereUniqueInput
  }

  export type WorkerUncheckedCreateNestedManyWithoutCrewsInput = {
    create?: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput> | WorkerCreateWithoutCrewsInput[] | WorkerUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewsInput | WorkerCreateOrConnectWithoutCrewsInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutCrewsNestedInput = {
    create?: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrewsInput
    upsert?: ProjectUpsertWithoutCrewsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCrewsInput, ProjectUpdateWithoutCrewsInput>, ProjectUncheckedUpdateWithoutCrewsInput>
  }

  export type WorkerUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput> | WorkerCreateWithoutCrewsInput[] | WorkerUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewsInput | WorkerCreateOrConnectWithoutCrewsInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCrewsInput | WorkerUpsertWithWhereUniqueWithoutCrewsInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCrewsInput | WorkerUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCrewsInput | WorkerUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutCrewsNestedInput = {
    create?: XOR<CompanyCreateWithoutCrewsInput, CompanyUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCrewsInput
    upsert?: CompanyUpsertWithoutCrewsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCrewsInput, CompanyUpdateWithoutCrewsInput>, CompanyUncheckedUpdateWithoutCrewsInput>
  }

  export type WorkerUncheckedUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput> | WorkerCreateWithoutCrewsInput[] | WorkerUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCrewsInput | WorkerCreateOrConnectWithoutCrewsInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCrewsInput | WorkerUpsertWithWhereUniqueWithoutCrewsInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCrewsInput | WorkerUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCrewsInput | WorkerUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutJobTitlesInput = {
    create?: XOR<CompanyCreateWithoutJobTitlesInput, CompanyUncheckedCreateWithoutJobTitlesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobTitlesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutJobTitlesNestedInput = {
    create?: XOR<CompanyCreateWithoutJobTitlesInput, CompanyUncheckedCreateWithoutJobTitlesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobTitlesInput
    upsert?: CompanyUpsertWithoutJobTitlesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJobTitlesInput, CompanyUpdateWithoutJobTitlesInput>, CompanyUncheckedUpdateWithoutJobTitlesInput>
  }

  export type ClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvoicesInput
    connect?: ProjectWhereUniqueInput
  }

  export type CostCenterCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CostCenterCreateWithoutInvoicesInput, CostCenterUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutInvoicesInput
    connect?: CostCenterWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutRelatedByInvoicesInput = {
    create?: XOR<InvoiceCreateWithoutRelatedByInvoicesInput, InvoiceUncheckedCreateWithoutRelatedByInvoicesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedByInvoicesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutRelatedInvoiceInput = {
    create?: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput> | InvoiceCreateWithoutRelatedInvoiceInput[] | InvoiceUncheckedCreateWithoutRelatedInvoiceInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedInvoiceInput | InvoiceCreateOrConnectWithoutRelatedInvoiceInput[]
    createMany?: InvoiceCreateManyRelatedInvoiceInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput = {
    create?: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput> | InvoiceCreateWithoutRelatedInvoiceInput[] | InvoiceUncheckedCreateWithoutRelatedInvoiceInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedInvoiceInput | InvoiceCreateOrConnectWithoutRelatedInvoiceInput[]
    createMany?: InvoiceCreateManyRelatedInvoiceInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClientUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    upsert?: ClientUpsertWithoutInvoicesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInvoicesInput, ClientUpdateWithoutInvoicesInput>, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ProjectUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvoicesInput
    upsert?: ProjectUpsertWithoutInvoicesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInvoicesInput, ProjectUpdateWithoutInvoicesInput>, ProjectUncheckedUpdateWithoutInvoicesInput>
  }

  export type CostCenterUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CostCenterCreateWithoutInvoicesInput, CostCenterUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutInvoicesInput
    upsert?: CostCenterUpsertWithoutInvoicesInput
    disconnect?: CostCenterWhereInput | boolean
    delete?: CostCenterWhereInput | boolean
    connect?: CostCenterWhereUniqueInput
    update?: XOR<XOR<CostCenterUpdateToOneWithWhereWithoutInvoicesInput, CostCenterUpdateWithoutInvoicesInput>, CostCenterUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput = {
    create?: XOR<InvoiceCreateWithoutRelatedByInvoicesInput, InvoiceUncheckedCreateWithoutRelatedByInvoicesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedByInvoicesInput
    upsert?: InvoiceUpsertWithoutRelatedByInvoicesInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutRelatedByInvoicesInput, InvoiceUpdateWithoutRelatedByInvoicesInput>, InvoiceUncheckedUpdateWithoutRelatedByInvoicesInput>
  }

  export type InvoiceUpdateManyWithoutRelatedInvoiceNestedInput = {
    create?: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput> | InvoiceCreateWithoutRelatedInvoiceInput[] | InvoiceUncheckedCreateWithoutRelatedInvoiceInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedInvoiceInput | InvoiceCreateOrConnectWithoutRelatedInvoiceInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRelatedInvoiceInput | InvoiceUpsertWithWhereUniqueWithoutRelatedInvoiceInput[]
    createMany?: InvoiceCreateManyRelatedInvoiceInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRelatedInvoiceInput | InvoiceUpdateWithWhereUniqueWithoutRelatedInvoiceInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRelatedInvoiceInput | InvoiceUpdateManyWithWhereWithoutRelatedInvoiceInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    upsert?: CompanyUpsertWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoicesInput, CompanyUpdateWithoutInvoicesInput>, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput = {
    create?: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput> | InvoiceCreateWithoutRelatedInvoiceInput[] | InvoiceUncheckedCreateWithoutRelatedInvoiceInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutRelatedInvoiceInput | InvoiceCreateOrConnectWithoutRelatedInvoiceInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutRelatedInvoiceInput | InvoiceUpsertWithWhereUniqueWithoutRelatedInvoiceInput[]
    createMany?: InvoiceCreateManyRelatedInvoiceInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutRelatedInvoiceInput | InvoiceUpdateWithWhereUniqueWithoutRelatedInvoiceInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutRelatedInvoiceInput | InvoiceUpdateManyWithWhereWithoutRelatedInvoiceInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutDailyReportsInput = {
    create?: XOR<UserCreateWithoutDailyReportsInput, UserUncheckedCreateWithoutDailyReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutDailyReportsInput = {
    create?: XOR<ProjectCreateWithoutDailyReportsInput, ProjectUncheckedCreateWithoutDailyReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDailyReportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDailyReportInput = {
    create?: XOR<CompanyCreateWithoutDailyReportInput, CompanyUncheckedCreateWithoutDailyReportInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDailyReportInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyReportsNestedInput = {
    create?: XOR<UserCreateWithoutDailyReportsInput, UserUncheckedCreateWithoutDailyReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyReportsInput
    upsert?: UserUpsertWithoutDailyReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyReportsInput, UserUpdateWithoutDailyReportsInput>, UserUncheckedUpdateWithoutDailyReportsInput>
  }

  export type ProjectUpdateOneWithoutDailyReportsNestedInput = {
    create?: XOR<ProjectCreateWithoutDailyReportsInput, ProjectUncheckedCreateWithoutDailyReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDailyReportsInput
    upsert?: ProjectUpsertWithoutDailyReportsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDailyReportsInput, ProjectUpdateWithoutDailyReportsInput>, ProjectUncheckedUpdateWithoutDailyReportsInput>
  }

  export type CompanyUpdateOneRequiredWithoutDailyReportNestedInput = {
    create?: XOR<CompanyCreateWithoutDailyReportInput, CompanyUncheckedCreateWithoutDailyReportInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDailyReportInput
    upsert?: CompanyUpsertWithoutDailyReportInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDailyReportInput, CompanyUpdateWithoutDailyReportInput>, CompanyUncheckedUpdateWithoutDailyReportInput>
  }

  export type ProjectCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchaseOrdersInput
    connect?: ProjectWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: ProjectUpsertWithoutPurchaseOrdersInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPurchaseOrdersInput, ProjectUpdateWithoutPurchaseOrdersInput>, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: CompanyUpsertWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput, CompanyUpdateWithoutPurchaseOrdersInput>, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type DocumentRequirementCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutDocumentsInput
    connect?: DocumentRequirementWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentRequirementUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentRequirementCreateOrConnectWithoutDocumentsInput
    upsert?: DocumentRequirementUpsertWithoutDocumentsInput
    disconnect?: DocumentRequirementWhereInput | boolean
    delete?: DocumentRequirementWhereInput | boolean
    connect?: DocumentRequirementWhereUniqueInput
    update?: XOR<XOR<DocumentRequirementUpdateToOneWithWhereWithoutDocumentsInput, DocumentRequirementUpdateWithoutDocumentsInput>, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementsInput
    connect?: ClientWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutRequirementInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<CompanyCreateWithoutRequirementsInput, CompanyUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRequirementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRequirementsInput
    upsert?: ClientUpsertWithoutRequirementsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRequirementsInput, ClientUpdateWithoutRequirementsInput>, ClientUncheckedUpdateWithoutRequirementsInput>
  }

  export type DocumentUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRequirementInput | DocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRequirementInput | DocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRequirementInput | DocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<CompanyCreateWithoutRequirementsInput, CompanyUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRequirementsInput
    upsert?: CompanyUpsertWithoutRequirementsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRequirementsInput, CompanyUpdateWithoutRequirementsInput>, CompanyUncheckedUpdateWithoutRequirementsInput>
  }

  export type DocumentUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput> | DocumentCreateWithoutRequirementInput[] | DocumentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRequirementInput | DocumentCreateOrConnectWithoutRequirementInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRequirementInput | DocumentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: DocumentCreateManyRequirementInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRequirementInput | DocumentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRequirementInput | DocumentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutMaterialInput = {
    create?: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput> | InventoryMovementCreateWithoutMaterialInput[] | InventoryMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMaterialInput | InventoryMovementCreateOrConnectWithoutMaterialInput[]
    createMany?: InventoryMovementCreateManyMaterialInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutMaterialInput = {
    create?: XOR<CompanyCreateWithoutMaterialInput, CompanyUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMaterialInput
    connect?: CompanyWhereUniqueInput
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput> | InventoryMovementCreateWithoutMaterialInput[] | InventoryMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMaterialInput | InventoryMovementCreateOrConnectWithoutMaterialInput[]
    createMany?: InventoryMovementCreateManyMaterialInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput> | InventoryMovementCreateWithoutMaterialInput[] | InventoryMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMaterialInput | InventoryMovementCreateOrConnectWithoutMaterialInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutMaterialInput | InventoryMovementUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: InventoryMovementCreateManyMaterialInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutMaterialInput | InventoryMovementUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutMaterialInput | InventoryMovementUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutMaterialNestedInput = {
    create?: XOR<CompanyCreateWithoutMaterialInput, CompanyUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMaterialInput
    upsert?: CompanyUpsertWithoutMaterialInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMaterialInput, CompanyUpdateWithoutMaterialInput>, CompanyUncheckedUpdateWithoutMaterialInput>
  }

  export type InventoryMovementUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput> | InventoryMovementCreateWithoutMaterialInput[] | InventoryMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMaterialInput | InventoryMovementCreateOrConnectWithoutMaterialInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutMaterialInput | InventoryMovementUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: InventoryMovementCreateManyMaterialInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutMaterialInput | InventoryMovementUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutMaterialInput | InventoryMovementUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutMovementsInput = {
    create?: XOR<MaterialCreateWithoutMovementsInput, MaterialUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMovementsInput
    connect?: MaterialWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<ProjectCreateWithoutInventoryMovementsInput, ProjectUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryMovementsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<CompanyCreateWithoutInventoryMovementsInput, CompanyUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInventoryMovementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type MaterialUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<MaterialCreateWithoutMovementsInput, MaterialUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMovementsInput
    upsert?: MaterialUpsertWithoutMovementsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutMovementsInput, MaterialUpdateWithoutMovementsInput>, MaterialUncheckedUpdateWithoutMovementsInput>
  }

  export type ProjectUpdateOneWithoutInventoryMovementsNestedInput = {
    create?: XOR<ProjectCreateWithoutInventoryMovementsInput, ProjectUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryMovementsInput
    upsert?: ProjectUpsertWithoutInventoryMovementsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInventoryMovementsInput, ProjectUpdateWithoutInventoryMovementsInput>, ProjectUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type CompanyUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<CompanyCreateWithoutInventoryMovementsInput, CompanyUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInventoryMovementsInput
    upsert?: CompanyUpsertWithoutInventoryMovementsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInventoryMovementsInput, CompanyUpdateWithoutInventoryMovementsInput>, CompanyUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ClientCreateNestedOneWithoutMonthlyInfoInput = {
    create?: XOR<ClientCreateWithoutMonthlyInfoInput, ClientUncheckedCreateWithoutMonthlyInfoInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMonthlyInfoInput
    connect?: ClientWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutMonthlyInfoInput = {
    create?: XOR<CompanyCreateWithoutMonthlyInfoInput, CompanyUncheckedCreateWithoutMonthlyInfoInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMonthlyInfoInput
    connect?: CompanyWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutMonthlyInfoNestedInput = {
    create?: XOR<ClientCreateWithoutMonthlyInfoInput, ClientUncheckedCreateWithoutMonthlyInfoInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMonthlyInfoInput
    upsert?: ClientUpsertWithoutMonthlyInfoInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMonthlyInfoInput, ClientUpdateWithoutMonthlyInfoInput>, ClientUncheckedUpdateWithoutMonthlyInfoInput>
  }

  export type CompanyUpdateOneRequiredWithoutMonthlyInfoNestedInput = {
    create?: XOR<CompanyCreateWithoutMonthlyInfoInput, CompanyUncheckedCreateWithoutMonthlyInfoInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMonthlyInfoInput
    upsert?: CompanyUpsertWithoutMonthlyInfoInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMonthlyInfoInput, CompanyUpdateWithoutMonthlyInfoInput>, CompanyUncheckedUpdateWithoutMonthlyInfoInput>
  }

  export type ProjectCreateNestedOneWithoutPlansInput = {
    create?: XOR<ProjectCreateWithoutPlansInput, ProjectUncheckedCreateWithoutPlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPlansInput
    connect?: ProjectWhereUniqueInput
  }

  export type CostCenterCreateNestedOneWithoutPlansInput = {
    create?: XOR<CostCenterCreateWithoutPlansInput, CostCenterUncheckedCreateWithoutPlansInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutPlansInput
    connect?: CostCenterWhereUniqueInput
  }

  export type PlanMarkCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput> | PlanMarkCreateWithoutPlanInput[] | PlanMarkUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutPlanInput | PlanMarkCreateOrConnectWithoutPlanInput[]
    createMany?: PlanMarkCreateManyPlanInputEnvelope
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutPlanInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput
    connect?: CompanyWhereUniqueInput
  }

  export type PlanMarkUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput> | PlanMarkCreateWithoutPlanInput[] | PlanMarkUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutPlanInput | PlanMarkCreateOrConnectWithoutPlanInput[]
    createMany?: PlanMarkCreateManyPlanInputEnvelope
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutPlansNestedInput = {
    create?: XOR<ProjectCreateWithoutPlansInput, ProjectUncheckedCreateWithoutPlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPlansInput
    upsert?: ProjectUpsertWithoutPlansInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPlansInput, ProjectUpdateWithoutPlansInput>, ProjectUncheckedUpdateWithoutPlansInput>
  }

  export type CostCenterUpdateOneWithoutPlansNestedInput = {
    create?: XOR<CostCenterCreateWithoutPlansInput, CostCenterUncheckedCreateWithoutPlansInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutPlansInput
    upsert?: CostCenterUpsertWithoutPlansInput
    disconnect?: CostCenterWhereInput | boolean
    delete?: CostCenterWhereInput | boolean
    connect?: CostCenterWhereUniqueInput
    update?: XOR<XOR<CostCenterUpdateToOneWithWhereWithoutPlansInput, CostCenterUpdateWithoutPlansInput>, CostCenterUncheckedUpdateWithoutPlansInput>
  }

  export type PlanMarkUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput> | PlanMarkCreateWithoutPlanInput[] | PlanMarkUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutPlanInput | PlanMarkCreateOrConnectWithoutPlanInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutPlanInput | PlanMarkUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanMarkCreateManyPlanInputEnvelope
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutPlanInput | PlanMarkUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutPlanInput | PlanMarkUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput
    upsert?: CompanyUpsertWithoutPlanInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPlanInput, CompanyUpdateWithoutPlanInput>, CompanyUncheckedUpdateWithoutPlanInput>
  }

  export type PlanMarkUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput> | PlanMarkCreateWithoutPlanInput[] | PlanMarkUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanMarkCreateOrConnectWithoutPlanInput | PlanMarkCreateOrConnectWithoutPlanInput[]
    upsert?: PlanMarkUpsertWithWhereUniqueWithoutPlanInput | PlanMarkUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanMarkCreateManyPlanInputEnvelope
    set?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    disconnect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    delete?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    connect?: PlanMarkWhereUniqueInput | PlanMarkWhereUniqueInput[]
    update?: PlanMarkUpdateWithWhereUniqueWithoutPlanInput | PlanMarkUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanMarkUpdateManyWithWhereWithoutPlanInput | PlanMarkUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutMarksInput = {
    create?: XOR<PlanCreateWithoutMarksInput, PlanUncheckedCreateWithoutMarksInput>
    connectOrCreate?: PlanCreateOrConnectWithoutMarksInput
    connect?: PlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlanMarksInput = {
    create?: XOR<UserCreateWithoutPlanMarksInput, UserUncheckedCreateWithoutPlanMarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanMarksInput
    connect?: UserWhereUniqueInput
  }

  export type WorkerCreateNestedManyWithoutPlanMarksInput = {
    create?: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput> | WorkerCreateWithoutPlanMarksInput[] | WorkerUncheckedCreateWithoutPlanMarksInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutPlanMarksInput | WorkerCreateOrConnectWithoutPlanMarksInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutPlanMarksInput = {
    create?: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput> | WorkerCreateWithoutPlanMarksInput[] | WorkerUncheckedCreateWithoutPlanMarksInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutPlanMarksInput | WorkerCreateOrConnectWithoutPlanMarksInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type PlanUpdateOneRequiredWithoutMarksNestedInput = {
    create?: XOR<PlanCreateWithoutMarksInput, PlanUncheckedCreateWithoutMarksInput>
    connectOrCreate?: PlanCreateOrConnectWithoutMarksInput
    upsert?: PlanUpsertWithoutMarksInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutMarksInput, PlanUpdateWithoutMarksInput>, PlanUncheckedUpdateWithoutMarksInput>
  }

  export type UserUpdateOneRequiredWithoutPlanMarksNestedInput = {
    create?: XOR<UserCreateWithoutPlanMarksInput, UserUncheckedCreateWithoutPlanMarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanMarksInput
    upsert?: UserUpsertWithoutPlanMarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlanMarksInput, UserUpdateWithoutPlanMarksInput>, UserUncheckedUpdateWithoutPlanMarksInput>
  }

  export type WorkerUpdateManyWithoutPlanMarksNestedInput = {
    create?: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput> | WorkerCreateWithoutPlanMarksInput[] | WorkerUncheckedCreateWithoutPlanMarksInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutPlanMarksInput | WorkerCreateOrConnectWithoutPlanMarksInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutPlanMarksInput | WorkerUpsertWithWhereUniqueWithoutPlanMarksInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutPlanMarksInput | WorkerUpdateWithWhereUniqueWithoutPlanMarksInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutPlanMarksInput | WorkerUpdateManyWithWhereWithoutPlanMarksInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutPlanMarksNestedInput = {
    create?: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput> | WorkerCreateWithoutPlanMarksInput[] | WorkerUncheckedCreateWithoutPlanMarksInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutPlanMarksInput | WorkerCreateOrConnectWithoutPlanMarksInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutPlanMarksInput | WorkerUpsertWithWhereUniqueWithoutPlanMarksInput[]
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutPlanMarksInput | WorkerUpdateWithWhereUniqueWithoutPlanMarksInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutPlanMarksInput | WorkerUpdateManyWithWhereWithoutPlanMarksInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type DailyReportCreateWithoutUserInput = {
    id?: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutDailyReportsInput
    company: CompanyCreateNestedOneWithoutDailyReportInput
  }

  export type DailyReportUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DailyReportCreateOrConnectWithoutUserInput = {
    where: DailyReportWhereUniqueInput
    create: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput>
  }

  export type DailyReportCreateManyUserInputEnvelope = {
    data: DailyReportCreateManyUserInput | DailyReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlanMarkCreateWithoutUserInput = {
    id?: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutMarksInput
    workers?: WorkerCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: WorkerUncheckedCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkCreateOrConnectWithoutUserInput = {
    where: PlanMarkWhereUniqueInput
    create: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput>
  }

  export type PlanMarkCreateManyUserInputEnvelope = {
    data: PlanMarkCreateManyUserInput | PlanMarkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithWhereUniqueWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateManyWithWhereWithoutUsersInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutUsersInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: StringFilter<"Company"> | string
    rut?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type DailyReportUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyReportWhereUniqueInput
    update: XOR<DailyReportUpdateWithoutUserInput, DailyReportUncheckedUpdateWithoutUserInput>
    create: XOR<DailyReportCreateWithoutUserInput, DailyReportUncheckedCreateWithoutUserInput>
  }

  export type DailyReportUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyReportWhereUniqueInput
    data: XOR<DailyReportUpdateWithoutUserInput, DailyReportUncheckedUpdateWithoutUserInput>
  }

  export type DailyReportUpdateManyWithWhereWithoutUserInput = {
    where: DailyReportScalarWhereInput
    data: XOR<DailyReportUpdateManyMutationInput, DailyReportUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyReportScalarWhereInput = {
    AND?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
    OR?: DailyReportScalarWhereInput[]
    NOT?: DailyReportScalarWhereInput | DailyReportScalarWhereInput[]
    id?: StringFilter<"DailyReport"> | string
    userId?: StringFilter<"DailyReport"> | string
    date?: DateTimeFilter<"DailyReport"> | Date | string
    content?: StringFilter<"DailyReport"> | string
    projectId?: StringNullableFilter<"DailyReport"> | string | null
    createdAt?: DateTimeFilter<"DailyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReport"> | Date | string
    companyId?: StringFilter<"DailyReport"> | string
  }

  export type PlanMarkUpsertWithWhereUniqueWithoutUserInput = {
    where: PlanMarkWhereUniqueInput
    update: XOR<PlanMarkUpdateWithoutUserInput, PlanMarkUncheckedUpdateWithoutUserInput>
    create: XOR<PlanMarkCreateWithoutUserInput, PlanMarkUncheckedCreateWithoutUserInput>
  }

  export type PlanMarkUpdateWithWhereUniqueWithoutUserInput = {
    where: PlanMarkWhereUniqueInput
    data: XOR<PlanMarkUpdateWithoutUserInput, PlanMarkUncheckedUpdateWithoutUserInput>
  }

  export type PlanMarkUpdateManyWithWhereWithoutUserInput = {
    where: PlanMarkScalarWhereInput
    data: XOR<PlanMarkUpdateManyMutationInput, PlanMarkUncheckedUpdateManyWithoutUserInput>
  }

  export type PlanMarkScalarWhereInput = {
    AND?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
    OR?: PlanMarkScalarWhereInput[]
    NOT?: PlanMarkScalarWhereInput | PlanMarkScalarWhereInput[]
    id?: StringFilter<"PlanMark"> | string
    planId?: StringFilter<"PlanMark"> | string
    userId?: StringFilter<"PlanMark"> | string
    x?: FloatFilter<"PlanMark"> | number
    y?: FloatFilter<"PlanMark"> | number
    points?: JsonNullableFilter<"PlanMark">
    type?: StringFilter<"PlanMark"> | string
    date?: DateTimeFilter<"PlanMark"> | Date | string
    meters?: FloatFilter<"PlanMark"> | number
    comment?: StringNullableFilter<"PlanMark"> | string | null
    imageUrl?: StringNullableFilter<"PlanMark"> | string | null
    stage?: IntFilter<"PlanMark"> | number
    createdAt?: DateTimeFilter<"PlanMark"> | Date | string
    updatedAt?: DateTimeFilter<"PlanMark"> | Date | string
  }

  export type UserCreateWithoutCompaniesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyReports?: DailyReportCreateNestedManyWithoutUserInput
    planMarks?: PlanMarkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutUserInput
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type ClientCreateWithoutCompanyInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCompanyInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCreateManyCompanyInputEnvelope = {
    data: ClientCreateManyCompanyInput | ClientCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput>
  }

  export type ProjectCreateManyCompanyInputEnvelope = {
    data: ProjectCreateManyCompanyInput | ProjectCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCompanyInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceCreateManyCompanyInputEnvelope = {
    data: InvoiceCreateManyCompanyInput | InvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCompanyInput = {
    id?: string
    name: string
    url: string
    type: string
    createdAt?: Date | string
    status?: string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
  }

  export type DocumentCreateOrConnectWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentCreateManyCompanyInputEnvelope = {
    data: DocumentCreateManyCompanyInput | DocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentRequirementCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementsInput
    documents?: DocumentCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementCreateOrConnectWithoutCompanyInput = {
    where: DocumentRequirementWhereUniqueInput
    create: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentRequirementCreateManyCompanyInputEnvelope = {
    data: DocumentRequirementCreateManyCompanyInput | DocumentRequirementCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ClientMonthlyInfoCreateWithoutCompanyInput = {
    id?: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutMonthlyInfoInput
  }

  export type ClientMonthlyInfoUncheckedCreateWithoutCompanyInput = {
    id?: string
    clientId: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientMonthlyInfoCreateOrConnectWithoutCompanyInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    create: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput>
  }

  export type ClientMonthlyInfoCreateManyCompanyInputEnvelope = {
    data: ClientMonthlyInfoCreateManyCompanyInput | ClientMonthlyInfoCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WorkerCreateWithoutCompanyInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewCreateNestedManyWithoutWorkersInput
    planMarks?: PlanMarkCreateNestedManyWithoutWorkersInput
  }

  export type WorkerUncheckedCreateWithoutCompanyInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewUncheckedCreateNestedManyWithoutWorkersInput
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerCreateOrConnectWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput>
  }

  export type WorkerCreateManyCompanyInputEnvelope = {
    data: WorkerCreateManyCompanyInput | WorkerCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutCompanyInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCrewsInput
    workers?: WorkerCreateNestedManyWithoutCrewsInput
  }

  export type CrewUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    role?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: WorkerUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type CrewCreateOrConnectWithoutCompanyInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput>
  }

  export type CrewCreateManyCompanyInputEnvelope = {
    data: CrewCreateManyCompanyInput | CrewCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCompanyInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCompanyInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderCreateManyCompanyInputEnvelope = {
    data: PurchaseOrderCreateManyCompanyInput | PurchaseOrderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutCompanyInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutMovementsInput
    project?: ProjectCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    projectId?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutCompanyInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput>
  }

  export type InventoryMovementCreateManyCompanyInputEnvelope = {
    data: InventoryMovementCreateManyCompanyInput | InventoryMovementCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CostCenterCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutCostCenterInput
    plans?: PlanCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCostCenterInput
    plans?: PlanUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterCreateOrConnectWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput>
  }

  export type CostCenterCreateManyCompanyInputEnvelope = {
    data: CostCenterCreateManyCompanyInput | CostCenterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DailyReportCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyReportsInput
    project?: ProjectCreateNestedOneWithoutDailyReportsInput
  }

  export type DailyReportUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReportCreateOrConnectWithoutCompanyInput = {
    where: DailyReportWhereUniqueInput
    create: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput>
  }

  export type DailyReportCreateManyCompanyInputEnvelope = {
    data: DailyReportCreateManyCompanyInput | DailyReportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutCompanyInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutCompanyInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutCompanyInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput>
  }

  export type MaterialCreateManyCompanyInputEnvelope = {
    data: MaterialCreateManyCompanyInput | MaterialCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutCompanyInput = {
    id?: string
    name: string
    imageUrl: string
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPlansInput
    costCenter?: CostCenterCreateNestedOneWithoutPlansInput
    marks?: PlanMarkCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    marks?: PlanMarkUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutCompanyInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
  }

  export type PlanCreateManyCompanyInputEnvelope = {
    data: PlanCreateManyCompanyInput | PlanCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JobTitleCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleCreateOrConnectWithoutCompanyInput = {
    where: JobTitleWhereUniqueInput
    create: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput>
  }

  export type JobTitleCreateManyCompanyInputEnvelope = {
    data: JobTitleCreateManyCompanyInput | JobTitleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateManyWithWhereWithoutCompaniesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    allowedSections?: StringNullableListFilter<"User">
    assignedProjectIds?: StringNullableListFilter<"User">
    activeCompanyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    rut?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    companyId?: StringFilter<"Client"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCompanyInput, ProjectUncheckedUpdateWithoutCompanyInput>
    create: XOR<ProjectCreateWithoutCompanyInput, ProjectUncheckedCreateWithoutCompanyInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCompanyInput, ProjectUncheckedUpdateWithoutCompanyInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCompanyInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    clientId?: StringNullableFilter<"Project"> | string | null
    progress?: IntFilter<"Project"> | number
    budget?: FloatFilter<"Project"> | number
    address?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    workerIds?: StringNullableListFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    companyId?: StringFilter<"Project"> | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    status?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    emissionType?: StringFilter<"Invoice"> | string
    purchaseOrderNumber?: StringNullableFilter<"Invoice"> | string | null
    dispatchGuideNumber?: StringNullableFilter<"Invoice"> | string | null
    netAmount?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    clientId?: StringNullableFilter<"Invoice"> | string | null
    projectId?: StringNullableFilter<"Invoice"> | string | null
    costCenterId?: StringNullableFilter<"Invoice"> | string | null
    relatedInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    isPaid?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    projectId?: StringNullableFilter<"Document"> | string | null
    clientId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    requirementId?: StringNullableFilter<"Document"> | string | null
    status?: StringFilter<"Document"> | string
    companyId?: StringFilter<"Document"> | string
  }

  export type DocumentRequirementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentRequirementWhereUniqueInput
    update: XOR<DocumentRequirementUpdateWithoutCompanyInput, DocumentRequirementUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentRequirementCreateWithoutCompanyInput, DocumentRequirementUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentRequirementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentRequirementWhereUniqueInput
    data: XOR<DocumentRequirementUpdateWithoutCompanyInput, DocumentRequirementUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentRequirementUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentRequirementScalarWhereInput
    data: XOR<DocumentRequirementUpdateManyMutationInput, DocumentRequirementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentRequirementScalarWhereInput = {
    AND?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
    OR?: DocumentRequirementScalarWhereInput[]
    NOT?: DocumentRequirementScalarWhereInput | DocumentRequirementScalarWhereInput[]
    id?: StringFilter<"DocumentRequirement"> | string
    name?: StringFilter<"DocumentRequirement"> | string
    description?: StringNullableFilter<"DocumentRequirement"> | string | null
    month?: IntNullableFilter<"DocumentRequirement"> | number | null
    year?: IntNullableFilter<"DocumentRequirement"> | number | null
    status?: StringFilter<"DocumentRequirement"> | string
    dueDate?: DateTimeNullableFilter<"DocumentRequirement"> | Date | string | null
    clientId?: StringFilter<"DocumentRequirement"> | string
    createdAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentRequirement"> | Date | string
    companyId?: StringFilter<"DocumentRequirement"> | string
  }

  export type ClientMonthlyInfoUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    update: XOR<ClientMonthlyInfoUpdateWithoutCompanyInput, ClientMonthlyInfoUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientMonthlyInfoCreateWithoutCompanyInput, ClientMonthlyInfoUncheckedCreateWithoutCompanyInput>
  }

  export type ClientMonthlyInfoUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    data: XOR<ClientMonthlyInfoUpdateWithoutCompanyInput, ClientMonthlyInfoUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientMonthlyInfoUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientMonthlyInfoScalarWhereInput
    data: XOR<ClientMonthlyInfoUpdateManyMutationInput, ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientMonthlyInfoScalarWhereInput = {
    AND?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
    OR?: ClientMonthlyInfoScalarWhereInput[]
    NOT?: ClientMonthlyInfoScalarWhereInput | ClientMonthlyInfoScalarWhereInput[]
    id?: StringFilter<"ClientMonthlyInfo"> | string
    clientId?: StringFilter<"ClientMonthlyInfo"> | string
    month?: IntFilter<"ClientMonthlyInfo"> | number
    year?: IntFilter<"ClientMonthlyInfo"> | number
    edpDate?: DateTimeNullableFilter<"ClientMonthlyInfo"> | Date | string | null
    createdAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ClientMonthlyInfo"> | Date | string
    companyId?: StringFilter<"ClientMonthlyInfo"> | string
  }

  export type WorkerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutCompanyInput, WorkerUncheckedUpdateWithoutCompanyInput>
    create: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutCompanyInput, WorkerUncheckedUpdateWithoutCompanyInput>
  }

  export type WorkerUpdateManyWithWhereWithoutCompanyInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    OR?: WorkerScalarWhereInput[]
    NOT?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    id?: StringFilter<"Worker"> | string
    rut?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    role?: StringNullableFilter<"Worker"> | string | null
    specialty?: StringNullableFilter<"Worker"> | string | null
    email?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    experienceYears?: IntNullableFilter<"Worker"> | number | null
    certifications?: StringNullableListFilter<"Worker">
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    companyId?: StringFilter<"Worker"> | string
  }

  export type CrewUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutCompanyInput, CrewUncheckedUpdateWithoutCompanyInput>
    create: XOR<CrewCreateWithoutCompanyInput, CrewUncheckedCreateWithoutCompanyInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutCompanyInput, CrewUncheckedUpdateWithoutCompanyInput>
  }

  export type CrewUpdateManyWithWhereWithoutCompanyInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CrewScalarWhereInput = {
    AND?: CrewScalarWhereInput | CrewScalarWhereInput[]
    OR?: CrewScalarWhereInput[]
    NOT?: CrewScalarWhereInput | CrewScalarWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    role?: StringNullableFilter<"Crew"> | string | null
    projectId?: StringNullableFilter<"Crew"> | string | null
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
    companyId?: StringFilter<"Crew"> | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    number?: StringFilter<"PurchaseOrder"> | string
    provider?: StringFilter<"PurchaseOrder"> | string
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: StringFilter<"PurchaseOrder"> | string
    projectId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    companyId?: StringFilter<"PurchaseOrder"> | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutCompanyInput, InventoryMovementUncheckedUpdateWithoutCompanyInput>
    create: XOR<InventoryMovementCreateWithoutCompanyInput, InventoryMovementUncheckedCreateWithoutCompanyInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutCompanyInput, InventoryMovementUncheckedUpdateWithoutCompanyInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutCompanyInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: FloatFilter<"InventoryMovement"> | number
    date?: DateTimeFilter<"InventoryMovement"> | Date | string
    description?: StringNullableFilter<"InventoryMovement"> | string | null
    materialId?: StringFilter<"InventoryMovement"> | string
    projectId?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    companyId?: StringFilter<"InventoryMovement"> | string
  }

  export type CostCenterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    update: XOR<CostCenterUpdateWithoutCompanyInput, CostCenterUncheckedUpdateWithoutCompanyInput>
    create: XOR<CostCenterCreateWithoutCompanyInput, CostCenterUncheckedCreateWithoutCompanyInput>
  }

  export type CostCenterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CostCenterWhereUniqueInput
    data: XOR<CostCenterUpdateWithoutCompanyInput, CostCenterUncheckedUpdateWithoutCompanyInput>
  }

  export type CostCenterUpdateManyWithWhereWithoutCompanyInput = {
    where: CostCenterScalarWhereInput
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CostCenterScalarWhereInput = {
    AND?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
    OR?: CostCenterScalarWhereInput[]
    NOT?: CostCenterScalarWhereInput | CostCenterScalarWhereInput[]
    id?: StringFilter<"CostCenter"> | string
    code?: StringFilter<"CostCenter"> | string
    name?: StringFilter<"CostCenter"> | string
    budget?: FloatFilter<"CostCenter"> | number
    createAt?: DateTimeFilter<"CostCenter"> | Date | string
    updatedAt?: DateTimeFilter<"CostCenter"> | Date | string
    companyId?: StringFilter<"CostCenter"> | string
  }

  export type DailyReportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DailyReportWhereUniqueInput
    update: XOR<DailyReportUpdateWithoutCompanyInput, DailyReportUncheckedUpdateWithoutCompanyInput>
    create: XOR<DailyReportCreateWithoutCompanyInput, DailyReportUncheckedCreateWithoutCompanyInput>
  }

  export type DailyReportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DailyReportWhereUniqueInput
    data: XOR<DailyReportUpdateWithoutCompanyInput, DailyReportUncheckedUpdateWithoutCompanyInput>
  }

  export type DailyReportUpdateManyWithWhereWithoutCompanyInput = {
    where: DailyReportScalarWhereInput
    data: XOR<DailyReportUpdateManyMutationInput, DailyReportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type MaterialUpsertWithWhereUniqueWithoutCompanyInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutCompanyInput, MaterialUncheckedUpdateWithoutCompanyInput>
    create: XOR<MaterialCreateWithoutCompanyInput, MaterialUncheckedCreateWithoutCompanyInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutCompanyInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutCompanyInput, MaterialUncheckedUpdateWithoutCompanyInput>
  }

  export type MaterialUpdateManyWithWhereWithoutCompanyInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutCompanyInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    code?: StringNullableFilter<"Material"> | string | null
    name?: StringFilter<"Material"> | string
    unit?: StringFilter<"Material"> | string
    minStock?: FloatFilter<"Material"> | number
    currentStock?: FloatFilter<"Material"> | number
    price?: FloatFilter<"Material"> | number
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    companyId?: StringFilter<"Material"> | string
  }

  export type PlanUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutCompanyInput, PlanUncheckedUpdateWithoutCompanyInput>
    create: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutCompanyInput, PlanUncheckedUpdateWithoutCompanyInput>
  }

  export type PlanUpdateManyWithWhereWithoutCompanyInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    imageUrl?: StringFilter<"Plan"> | string
    projectId?: StringNullableFilter<"Plan"> | string | null
    costCenterId?: StringNullableFilter<"Plan"> | string | null
    stages?: IntFilter<"Plan"> | number
    systemType?: StringNullableFilter<"Plan"> | string | null
    installationType?: StringNullableFilter<"Plan"> | string | null
    installationDetail?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    companyId?: StringFilter<"Plan"> | string
  }

  export type JobTitleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JobTitleWhereUniqueInput
    update: XOR<JobTitleUpdateWithoutCompanyInput, JobTitleUncheckedUpdateWithoutCompanyInput>
    create: XOR<JobTitleCreateWithoutCompanyInput, JobTitleUncheckedCreateWithoutCompanyInput>
  }

  export type JobTitleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JobTitleWhereUniqueInput
    data: XOR<JobTitleUpdateWithoutCompanyInput, JobTitleUncheckedUpdateWithoutCompanyInput>
  }

  export type JobTitleUpdateManyWithWhereWithoutCompanyInput = {
    where: JobTitleScalarWhereInput
    data: XOR<JobTitleUpdateManyMutationInput, JobTitleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JobTitleScalarWhereInput = {
    AND?: JobTitleScalarWhereInput | JobTitleScalarWhereInput[]
    OR?: JobTitleScalarWhereInput[]
    NOT?: JobTitleScalarWhereInput | JobTitleScalarWhereInput[]
    id?: StringFilter<"JobTitle"> | string
    name?: StringFilter<"JobTitle"> | string
    description?: StringNullableFilter<"JobTitle"> | string | null
    createdAt?: DateTimeFilter<"JobTitle"> | Date | string
    updatedAt?: DateTimeFilter<"JobTitle"> | Date | string
    companyId?: StringNullableFilter<"JobTitle"> | string | null
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutClientInput = {
    id?: string
    name: string
    url: string
    type: string
    createdAt?: Date | string
    status?: string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentRequirementCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutRequirementInput
    company: CompanyCreateNestedOneWithoutRequirementsInput
  }

  export type DocumentRequirementUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type DocumentRequirementCreateOrConnectWithoutClientInput = {
    where: DocumentRequirementWhereUniqueInput
    create: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput>
  }

  export type DocumentRequirementCreateManyClientInputEnvelope = {
    data: DocumentRequirementCreateManyClientInput | DocumentRequirementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientMonthlyInfoCreateWithoutClientInput = {
    id?: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMonthlyInfoInput
  }

  export type ClientMonthlyInfoUncheckedCreateWithoutClientInput = {
    id?: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ClientMonthlyInfoCreateOrConnectWithoutClientInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    create: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput>
  }

  export type ClientMonthlyInfoCreateManyClientInputEnvelope = {
    data: ClientMonthlyInfoCreateManyClientInput | ClientMonthlyInfoCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutClientsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutClientsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutClientsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type DocumentRequirementUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentRequirementWhereUniqueInput
    update: XOR<DocumentRequirementUpdateWithoutClientInput, DocumentRequirementUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentRequirementCreateWithoutClientInput, DocumentRequirementUncheckedCreateWithoutClientInput>
  }

  export type DocumentRequirementUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentRequirementWhereUniqueInput
    data: XOR<DocumentRequirementUpdateWithoutClientInput, DocumentRequirementUncheckedUpdateWithoutClientInput>
  }

  export type DocumentRequirementUpdateManyWithWhereWithoutClientInput = {
    where: DocumentRequirementScalarWhereInput
    data: XOR<DocumentRequirementUpdateManyMutationInput, DocumentRequirementUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientMonthlyInfoUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    update: XOR<ClientMonthlyInfoUpdateWithoutClientInput, ClientMonthlyInfoUncheckedUpdateWithoutClientInput>
    create: XOR<ClientMonthlyInfoCreateWithoutClientInput, ClientMonthlyInfoUncheckedCreateWithoutClientInput>
  }

  export type ClientMonthlyInfoUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientMonthlyInfoWhereUniqueInput
    data: XOR<ClientMonthlyInfoUpdateWithoutClientInput, ClientMonthlyInfoUncheckedUpdateWithoutClientInput>
  }

  export type ClientMonthlyInfoUpdateManyWithWhereWithoutClientInput = {
    where: ClientMonthlyInfoScalarWhereInput
    data: XOR<ClientMonthlyInfoUpdateManyMutationInput, ClientMonthlyInfoUncheckedUpdateManyWithoutClientInput>
  }

  export type CompanyUpsertWithoutClientsInput = {
    update: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutClientsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type CompanyUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientCreateWithoutProjectsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutProjectsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProjectsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
  }

  export type CrewCreateWithoutProjectInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: WorkerCreateNestedManyWithoutCrewsInput
    company: CompanyCreateNestedOneWithoutCrewsInput
  }

  export type CrewUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    workers?: WorkerUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type CrewCreateOrConnectWithoutProjectInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput>
  }

  export type CrewCreateManyProjectInputEnvelope = {
    data: CrewCreateManyProjectInput | CrewCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutProjectInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutProjectInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput>
  }

  export type InvoiceCreateManyProjectInputEnvelope = {
    data: InvoiceCreateManyProjectInput | InvoiceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DailyReportCreateWithoutProjectInput = {
    id?: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyReportsInput
    company: CompanyCreateNestedOneWithoutDailyReportInput
  }

  export type DailyReportUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DailyReportCreateOrConnectWithoutProjectInput = {
    where: DailyReportWhereUniqueInput
    create: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput>
  }

  export type DailyReportCreateManyProjectInputEnvelope = {
    data: DailyReportCreateManyProjectInput | DailyReportCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    createdAt?: Date | string
    status?: string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    requirement?: DocumentRequirementCreateNestedOneWithoutDocumentsInput
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: DocumentCreateManyProjectInput | DocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutProjectInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutProjectInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseOrderCreateManyProjectInputEnvelope = {
    data: PurchaseOrderCreateManyProjectInput | PurchaseOrderCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutProjectInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutMovementsInput
    company: CompanyCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutProjectInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    createdAt?: Date | string
    companyId: string
  }

  export type InventoryMovementCreateOrConnectWithoutProjectInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput>
  }

  export type InventoryMovementCreateManyProjectInputEnvelope = {
    data: InventoryMovementCreateManyProjectInput | InventoryMovementCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutProjectInput = {
    id?: string
    name: string
    imageUrl: string
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costCenter?: CostCenterCreateNestedOneWithoutPlansInput
    marks?: PlanMarkCreateNestedManyWithoutPlanInput
    company: CompanyCreateNestedOneWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    imageUrl: string
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    marks?: PlanMarkUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutProjectInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput>
  }

  export type PlanCreateManyProjectInputEnvelope = {
    data: PlanCreateManyProjectInput | PlanCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutProjectsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProjectsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProjectsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
  }

  export type ClientUpsertWithoutProjectsInput = {
    update: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ClientUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CrewUpsertWithWhereUniqueWithoutProjectInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutProjectInput, CrewUncheckedUpdateWithoutProjectInput>
    create: XOR<CrewCreateWithoutProjectInput, CrewUncheckedCreateWithoutProjectInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutProjectInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutProjectInput, CrewUncheckedUpdateWithoutProjectInput>
  }

  export type CrewUpdateManyWithWhereWithoutProjectInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutProjectInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutProjectInput, InvoiceUncheckedUpdateWithoutProjectInput>
    create: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutProjectInput, InvoiceUncheckedUpdateWithoutProjectInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutProjectInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutProjectInput>
  }

  export type DailyReportUpsertWithWhereUniqueWithoutProjectInput = {
    where: DailyReportWhereUniqueInput
    update: XOR<DailyReportUpdateWithoutProjectInput, DailyReportUncheckedUpdateWithoutProjectInput>
    create: XOR<DailyReportCreateWithoutProjectInput, DailyReportUncheckedCreateWithoutProjectInput>
  }

  export type DailyReportUpdateWithWhereUniqueWithoutProjectInput = {
    where: DailyReportWhereUniqueInput
    data: XOR<DailyReportUpdateWithoutProjectInput, DailyReportUncheckedUpdateWithoutProjectInput>
  }

  export type DailyReportUpdateManyWithWhereWithoutProjectInput = {
    where: DailyReportScalarWhereInput
    data: XOR<DailyReportUpdateManyMutationInput, DailyReportUncheckedUpdateManyWithoutProjectInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutProjectInput, PurchaseOrderUncheckedUpdateWithoutProjectInput>
    create: XOR<PurchaseOrderCreateWithoutProjectInput, PurchaseOrderUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutProjectInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutProjectInput, PurchaseOrderUncheckedUpdateWithoutProjectInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutProjectInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutProjectInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutProjectInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutProjectInput, InventoryMovementUncheckedUpdateWithoutProjectInput>
    create: XOR<InventoryMovementCreateWithoutProjectInput, InventoryMovementUncheckedCreateWithoutProjectInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutProjectInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutProjectInput, InventoryMovementUncheckedUpdateWithoutProjectInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutProjectInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutProjectInput>
  }

  export type PlanUpsertWithWhereUniqueWithoutProjectInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutProjectInput, PlanUncheckedUpdateWithoutProjectInput>
    create: XOR<PlanCreateWithoutProjectInput, PlanUncheckedCreateWithoutProjectInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutProjectInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutProjectInput, PlanUncheckedUpdateWithoutProjectInput>
  }

  export type PlanUpdateManyWithWhereWithoutProjectInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutProjectInput>
  }

  export type CompanyUpsertWithoutProjectsInput = {
    update: XOR<CompanyUpdateWithoutProjectsInput, CompanyUncheckedUpdateWithoutProjectsInput>
    create: XOR<CompanyCreateWithoutProjectsInput, CompanyUncheckedCreateWithoutProjectsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProjectsInput, CompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type CompanyUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InvoiceCreateWithoutCostCenterInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCostCenterInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCostCenterInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput>
  }

  export type InvoiceCreateManyCostCenterInputEnvelope = {
    data: InvoiceCreateManyCostCenterInput | InvoiceCreateManyCostCenterInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutCostCenterInput = {
    id?: string
    name: string
    imageUrl: string
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPlansInput
    marks?: PlanMarkCreateNestedManyWithoutPlanInput
    company: CompanyCreateNestedOneWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutCostCenterInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    marks?: PlanMarkUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutCostCenterInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput>
  }

  export type PlanCreateManyCostCenterInputEnvelope = {
    data: PlanCreateManyCostCenterInput | PlanCreateManyCostCenterInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutCostCentersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCostCentersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCostCentersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCostCenterInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCostCenterInput, InvoiceUncheckedUpdateWithoutCostCenterInput>
    create: XOR<InvoiceCreateWithoutCostCenterInput, InvoiceUncheckedCreateWithoutCostCenterInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCostCenterInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCostCenterInput, InvoiceUncheckedUpdateWithoutCostCenterInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCostCenterInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCostCenterInput>
  }

  export type PlanUpsertWithWhereUniqueWithoutCostCenterInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutCostCenterInput, PlanUncheckedUpdateWithoutCostCenterInput>
    create: XOR<PlanCreateWithoutCostCenterInput, PlanUncheckedCreateWithoutCostCenterInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutCostCenterInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutCostCenterInput, PlanUncheckedUpdateWithoutCostCenterInput>
  }

  export type PlanUpdateManyWithWhereWithoutCostCenterInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutCostCenterInput>
  }

  export type CompanyUpsertWithoutCostCentersInput = {
    update: XOR<CompanyUpdateWithoutCostCentersInput, CompanyUncheckedUpdateWithoutCostCentersInput>
    create: XOR<CompanyCreateWithoutCostCentersInput, CompanyUncheckedCreateWithoutCostCentersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCostCentersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCostCentersInput, CompanyUncheckedUpdateWithoutCostCentersInput>
  }

  export type CompanyUpdateWithoutCostCentersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCostCentersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CrewCreateWithoutWorkersInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCrewsInput
    company: CompanyCreateNestedOneWithoutCrewsInput
  }

  export type CrewUncheckedCreateWithoutWorkersInput = {
    id?: string
    name: string
    role?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type CrewCreateOrConnectWithoutWorkersInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput>
  }

  export type PlanMarkCreateWithoutWorkersInput = {
    id?: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutMarksInput
    user: UserCreateNestedOneWithoutPlanMarksInput
  }

  export type PlanMarkUncheckedCreateWithoutWorkersInput = {
    id?: string
    planId: string
    userId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanMarkCreateOrConnectWithoutWorkersInput = {
    where: PlanMarkWhereUniqueInput
    create: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput>
  }

  export type CompanyCreateWithoutWorkersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWorkersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWorkersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
  }

  export type CrewUpsertWithWhereUniqueWithoutWorkersInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutWorkersInput, CrewUncheckedUpdateWithoutWorkersInput>
    create: XOR<CrewCreateWithoutWorkersInput, CrewUncheckedCreateWithoutWorkersInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutWorkersInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutWorkersInput, CrewUncheckedUpdateWithoutWorkersInput>
  }

  export type CrewUpdateManyWithWhereWithoutWorkersInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutWorkersInput>
  }

  export type PlanMarkUpsertWithWhereUniqueWithoutWorkersInput = {
    where: PlanMarkWhereUniqueInput
    update: XOR<PlanMarkUpdateWithoutWorkersInput, PlanMarkUncheckedUpdateWithoutWorkersInput>
    create: XOR<PlanMarkCreateWithoutWorkersInput, PlanMarkUncheckedCreateWithoutWorkersInput>
  }

  export type PlanMarkUpdateWithWhereUniqueWithoutWorkersInput = {
    where: PlanMarkWhereUniqueInput
    data: XOR<PlanMarkUpdateWithoutWorkersInput, PlanMarkUncheckedUpdateWithoutWorkersInput>
  }

  export type PlanMarkUpdateManyWithWhereWithoutWorkersInput = {
    where: PlanMarkScalarWhereInput
    data: XOR<PlanMarkUpdateManyMutationInput, PlanMarkUncheckedUpdateManyWithoutWorkersInput>
  }

  export type CompanyUpsertWithoutWorkersInput = {
    update: XOR<CompanyUpdateWithoutWorkersInput, CompanyUncheckedUpdateWithoutWorkersInput>
    create: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWorkersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWorkersInput, CompanyUncheckedUpdateWithoutWorkersInput>
  }

  export type CompanyUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectCreateWithoutCrewsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCrewsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCrewsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
  }

  export type WorkerCreateWithoutCrewsInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    planMarks?: PlanMarkCreateNestedManyWithoutWorkersInput
    company: CompanyCreateNestedOneWithoutWorkersInput
  }

  export type WorkerUncheckedCreateWithoutCrewsInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerCreateOrConnectWithoutCrewsInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput>
  }

  export type CompanyCreateWithoutCrewsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCrewsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCrewsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCrewsInput, CompanyUncheckedCreateWithoutCrewsInput>
  }

  export type ProjectUpsertWithoutCrewsInput = {
    update: XOR<ProjectUpdateWithoutCrewsInput, ProjectUncheckedUpdateWithoutCrewsInput>
    create: XOR<ProjectCreateWithoutCrewsInput, ProjectUncheckedCreateWithoutCrewsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCrewsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCrewsInput, ProjectUncheckedUpdateWithoutCrewsInput>
  }

  export type ProjectUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WorkerUpsertWithWhereUniqueWithoutCrewsInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutCrewsInput, WorkerUncheckedUpdateWithoutCrewsInput>
    create: XOR<WorkerCreateWithoutCrewsInput, WorkerUncheckedCreateWithoutCrewsInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutCrewsInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutCrewsInput, WorkerUncheckedUpdateWithoutCrewsInput>
  }

  export type WorkerUpdateManyWithWhereWithoutCrewsInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutCrewsInput>
  }

  export type CompanyUpsertWithoutCrewsInput = {
    update: XOR<CompanyUpdateWithoutCrewsInput, CompanyUncheckedUpdateWithoutCrewsInput>
    create: XOR<CompanyCreateWithoutCrewsInput, CompanyUncheckedCreateWithoutCrewsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCrewsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCrewsInput, CompanyUncheckedUpdateWithoutCrewsInput>
  }

  export type CompanyUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutJobTitlesInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJobTitlesInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJobTitlesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJobTitlesInput, CompanyUncheckedCreateWithoutJobTitlesInput>
  }

  export type CompanyUpsertWithoutJobTitlesInput = {
    update: XOR<CompanyUpdateWithoutJobTitlesInput, CompanyUncheckedUpdateWithoutJobTitlesInput>
    create: XOR<CompanyCreateWithoutJobTitlesInput, CompanyUncheckedCreateWithoutJobTitlesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJobTitlesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJobTitlesInput, CompanyUncheckedUpdateWithoutJobTitlesInput>
  }

  export type CompanyUpdateWithoutJobTitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJobTitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientCreateWithoutInvoicesInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInvoicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
  }

  export type ProjectCreateWithoutInvoicesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvoicesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
  }

  export type CostCenterCreateWithoutInvoicesInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    plans?: PlanCreateNestedManyWithoutCostCenterInput
    company: CompanyCreateNestedOneWithoutCostCentersInput
  }

  export type CostCenterUncheckedCreateWithoutInvoicesInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    plans?: PlanUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterCreateOrConnectWithoutInvoicesInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutInvoicesInput, CostCenterUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutRelatedByInvoicesInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutRelatedByInvoicesInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRelatedByInvoicesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRelatedByInvoicesInput, InvoiceUncheckedCreateWithoutRelatedByInvoicesInput>
  }

  export type InvoiceCreateWithoutRelatedInvoiceInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutRelatedInvoiceInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRelatedInvoiceInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput>
  }

  export type InvoiceCreateManyRelatedInvoiceInputEnvelope = {
    data: InvoiceCreateManyRelatedInvoiceInput | InvoiceCreateManyRelatedInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutInvoicesInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoicesInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
  }

  export type ClientUpsertWithoutInvoicesInput = {
    update: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectUpsertWithoutInvoicesInput = {
    update: XOR<ProjectUpdateWithoutInvoicesInput, ProjectUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInvoicesInput, ProjectUncheckedUpdateWithoutInvoicesInput>
  }

  export type ProjectUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CostCenterUpsertWithoutInvoicesInput = {
    update: XOR<CostCenterUpdateWithoutInvoicesInput, CostCenterUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CostCenterCreateWithoutInvoicesInput, CostCenterUncheckedCreateWithoutInvoicesInput>
    where?: CostCenterWhereInput
  }

  export type CostCenterUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CostCenterWhereInput
    data: XOR<CostCenterUpdateWithoutInvoicesInput, CostCenterUncheckedUpdateWithoutInvoicesInput>
  }

  export type CostCenterUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUpdateManyWithoutCostCenterNestedInput
    company?: CompanyUpdateOneRequiredWithoutCostCentersNestedInput
  }

  export type CostCenterUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    plans?: PlanUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    invoiceId?: StringFilter<"InvoiceItem"> | string
  }

  export type InvoiceUpsertWithoutRelatedByInvoicesInput = {
    update: XOR<InvoiceUpdateWithoutRelatedByInvoicesInput, InvoiceUncheckedUpdateWithoutRelatedByInvoicesInput>
    create: XOR<InvoiceCreateWithoutRelatedByInvoicesInput, InvoiceUncheckedCreateWithoutRelatedByInvoicesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutRelatedByInvoicesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutRelatedByInvoicesInput, InvoiceUncheckedUpdateWithoutRelatedByInvoicesInput>
  }

  export type InvoiceUpdateWithoutRelatedByInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRelatedByInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutRelatedInvoiceInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutRelatedInvoiceInput, InvoiceUncheckedUpdateWithoutRelatedInvoiceInput>
    create: XOR<InvoiceCreateWithoutRelatedInvoiceInput, InvoiceUncheckedCreateWithoutRelatedInvoiceInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutRelatedInvoiceInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutRelatedInvoiceInput, InvoiceUncheckedUpdateWithoutRelatedInvoiceInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutRelatedInvoiceInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutRelatedInvoiceInput>
  }

  export type CompanyUpsertWithoutInvoicesInput = {
    update: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutInvoicesInput
    project?: ProjectCreateNestedOneWithoutInvoicesInput
    costCenter?: CostCenterCreateNestedOneWithoutInvoicesInput
    relatedInvoice?: InvoiceCreateNestedOneWithoutRelatedByInvoicesInput
    relatedByInvoices?: InvoiceCreateNestedManyWithoutRelatedInvoiceInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    relatedByInvoices?: InvoiceUncheckedCreateNestedManyWithoutRelatedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type UserCreateWithoutDailyReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyCreateNestedManyWithoutUsersInput
    planMarks?: PlanMarkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUncheckedCreateNestedManyWithoutUsersInput
    planMarks?: PlanMarkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyReportsInput, UserUncheckedCreateWithoutDailyReportsInput>
  }

  export type ProjectCreateWithoutDailyReportsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutDailyReportsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDailyReportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDailyReportsInput, ProjectUncheckedCreateWithoutDailyReportsInput>
  }

  export type CompanyCreateWithoutDailyReportInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDailyReportInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDailyReportInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDailyReportInput, CompanyUncheckedCreateWithoutDailyReportInput>
  }

  export type UserUpsertWithoutDailyReportsInput = {
    update: XOR<UserUpdateWithoutDailyReportsInput, UserUncheckedUpdateWithoutDailyReportsInput>
    create: XOR<UserCreateWithoutDailyReportsInput, UserUncheckedCreateWithoutDailyReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyReportsInput, UserUncheckedUpdateWithoutDailyReportsInput>
  }

  export type UserUpdateWithoutDailyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUpdateManyWithoutUsersNestedInput
    planMarks?: PlanMarkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUncheckedUpdateManyWithoutUsersNestedInput
    planMarks?: PlanMarkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutDailyReportsInput = {
    update: XOR<ProjectUpdateWithoutDailyReportsInput, ProjectUncheckedUpdateWithoutDailyReportsInput>
    create: XOR<ProjectCreateWithoutDailyReportsInput, ProjectUncheckedCreateWithoutDailyReportsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDailyReportsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDailyReportsInput, ProjectUncheckedUpdateWithoutDailyReportsInput>
  }

  export type ProjectUpdateWithoutDailyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDailyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CompanyUpsertWithoutDailyReportInput = {
    update: XOR<CompanyUpdateWithoutDailyReportInput, CompanyUncheckedUpdateWithoutDailyReportInput>
    create: XOR<CompanyCreateWithoutDailyReportInput, CompanyUncheckedCreateWithoutDailyReportInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDailyReportInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDailyReportInput, CompanyUncheckedUpdateWithoutDailyReportInput>
  }

  export type CompanyUpdateWithoutDailyReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDailyReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPurchaseOrdersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutPurchaseOrdersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type ProjectUpsertWithoutPurchaseOrdersInput = {
    update: XOR<ProjectUpdateWithoutPurchaseOrdersInput, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<ProjectCreateWithoutPurchaseOrdersInput, ProjectUncheckedCreateWithoutPurchaseOrdersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPurchaseOrdersInput, ProjectUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type ProjectUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    total?: FloatFilter<"PurchaseOrderItem"> | number
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
  }

  export type CompanyUpsertWithoutPurchaseOrdersInput = {
    update: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CompanyUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentRequirementCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutRequirementsInput
    company: CompanyCreateNestedOneWithoutRequirementsInput
  }

  export type DocumentRequirementUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentRequirementCreateOrConnectWithoutDocumentsInput = {
    where: DocumentRequirementWhereUniqueInput
    create: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
  }

  export type CompanyCreateWithoutDocumentsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DocumentRequirementUpsertWithoutDocumentsInput = {
    update: XOR<DocumentRequirementUpdateWithoutDocumentsInput, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DocumentRequirementCreateWithoutDocumentsInput, DocumentRequirementUncheckedCreateWithoutDocumentsInput>
    where?: DocumentRequirementWhereInput
  }

  export type DocumentRequirementUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DocumentRequirementWhereInput
    data: XOR<DocumentRequirementUpdateWithoutDocumentsInput, DocumentRequirementUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentRequirementUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    company?: CompanyUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type DocumentRequirementUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientCreateWithoutRequirementsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutRequirementsInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutRequirementsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
  }

  export type DocumentCreateWithoutRequirementInput = {
    id?: string
    name: string
    url: string
    type: string
    createdAt?: Date | string
    status?: string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutRequirementInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    status?: string
    companyId: string
  }

  export type DocumentCreateOrConnectWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput>
  }

  export type DocumentCreateManyRequirementInputEnvelope = {
    data: DocumentCreateManyRequirementInput | DocumentCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutRequirementsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRequirementsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRequirementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRequirementsInput, CompanyUncheckedCreateWithoutRequirementsInput>
  }

  export type ClientUpsertWithoutRequirementsInput = {
    update: XOR<ClientUpdateWithoutRequirementsInput, ClientUncheckedUpdateWithoutRequirementsInput>
    create: XOR<ClientCreateWithoutRequirementsInput, ClientUncheckedCreateWithoutRequirementsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRequirementsInput, ClientUncheckedUpdateWithoutRequirementsInput>
  }

  export type ClientUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutRequirementInput, DocumentUncheckedUpdateWithoutRequirementInput>
    create: XOR<DocumentCreateWithoutRequirementInput, DocumentUncheckedCreateWithoutRequirementInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutRequirementInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutRequirementInput, DocumentUncheckedUpdateWithoutRequirementInput>
  }

  export type DocumentUpdateManyWithWhereWithoutRequirementInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutRequirementInput>
  }

  export type CompanyUpsertWithoutRequirementsInput = {
    update: XOR<CompanyUpdateWithoutRequirementsInput, CompanyUncheckedUpdateWithoutRequirementsInput>
    create: XOR<CompanyCreateWithoutRequirementsInput, CompanyUncheckedCreateWithoutRequirementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRequirementsInput, CompanyUncheckedUpdateWithoutRequirementsInput>
  }

  export type CompanyUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InventoryMovementCreateWithoutMaterialInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutInventoryMovementsInput
    company: CompanyCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutMaterialInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    projectId?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type InventoryMovementCreateOrConnectWithoutMaterialInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput>
  }

  export type InventoryMovementCreateManyMaterialInputEnvelope = {
    data: InventoryMovementCreateManyMaterialInput | InventoryMovementCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutMaterialInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMaterialInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMaterialInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMaterialInput, CompanyUncheckedCreateWithoutMaterialInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutMaterialInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutMaterialInput, InventoryMovementUncheckedUpdateWithoutMaterialInput>
    create: XOR<InventoryMovementCreateWithoutMaterialInput, InventoryMovementUncheckedCreateWithoutMaterialInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutMaterialInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutMaterialInput, InventoryMovementUncheckedUpdateWithoutMaterialInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutMaterialInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutMaterialInput>
  }

  export type CompanyUpsertWithoutMaterialInput = {
    update: XOR<CompanyUpdateWithoutMaterialInput, CompanyUncheckedUpdateWithoutMaterialInput>
    create: XOR<CompanyCreateWithoutMaterialInput, CompanyUncheckedCreateWithoutMaterialInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMaterialInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMaterialInput, CompanyUncheckedUpdateWithoutMaterialInput>
  }

  export type CompanyUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MaterialCreateWithoutMovementsInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutMovementsInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type MaterialCreateOrConnectWithoutMovementsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutMovementsInput, MaterialUncheckedCreateWithoutMovementsInput>
  }

  export type ProjectCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    plans?: PlanCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    plans?: PlanUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInventoryMovementsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInventoryMovementsInput, ProjectUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type CompanyCreateWithoutInventoryMovementsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInventoryMovementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInventoryMovementsInput, CompanyUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type MaterialUpsertWithoutMovementsInput = {
    update: XOR<MaterialUpdateWithoutMovementsInput, MaterialUncheckedUpdateWithoutMovementsInput>
    create: XOR<MaterialCreateWithoutMovementsInput, MaterialUncheckedCreateWithoutMovementsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutMovementsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutMovementsInput, MaterialUncheckedUpdateWithoutMovementsInput>
  }

  export type MaterialUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpsertWithoutInventoryMovementsInput = {
    update: XOR<ProjectUpdateWithoutInventoryMovementsInput, ProjectUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<ProjectCreateWithoutInventoryMovementsInput, ProjectUncheckedCreateWithoutInventoryMovementsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInventoryMovementsInput, ProjectUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProjectUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CompanyUpsertWithoutInventoryMovementsInput = {
    update: XOR<CompanyUpdateWithoutInventoryMovementsInput, CompanyUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<CompanyCreateWithoutInventoryMovementsInput, CompanyUncheckedCreateWithoutInventoryMovementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInventoryMovementsInput, CompanyUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type CompanyUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientCreateWithoutMonthlyInfoInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementCreateNestedManyWithoutClientInput
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutMonthlyInfoInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMonthlyInfoInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMonthlyInfoInput, ClientUncheckedCreateWithoutMonthlyInfoInput>
  }

  export type CompanyCreateWithoutMonthlyInfoInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    Plan?: PlanCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMonthlyInfoInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    Plan?: PlanUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMonthlyInfoInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMonthlyInfoInput, CompanyUncheckedCreateWithoutMonthlyInfoInput>
  }

  export type ClientUpsertWithoutMonthlyInfoInput = {
    update: XOR<ClientUpdateWithoutMonthlyInfoInput, ClientUncheckedUpdateWithoutMonthlyInfoInput>
    create: XOR<ClientCreateWithoutMonthlyInfoInput, ClientUncheckedCreateWithoutMonthlyInfoInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMonthlyInfoInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMonthlyInfoInput, ClientUncheckedUpdateWithoutMonthlyInfoInput>
  }

  export type ClientUpdateWithoutMonthlyInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutMonthlyInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CompanyUpsertWithoutMonthlyInfoInput = {
    update: XOR<CompanyUpdateWithoutMonthlyInfoInput, CompanyUncheckedUpdateWithoutMonthlyInfoInput>
    create: XOR<CompanyCreateWithoutMonthlyInfoInput, CompanyUncheckedCreateWithoutMonthlyInfoInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMonthlyInfoInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMonthlyInfoInput, CompanyUncheckedUpdateWithoutMonthlyInfoInput>
  }

  export type CompanyUpdateWithoutMonthlyInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMonthlyInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ProjectCreateWithoutPlansInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutProjectsInput
    crews?: CrewCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProjectInput
    company: CompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutProjectInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPlansInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPlansInput, ProjectUncheckedCreateWithoutPlansInput>
  }

  export type CostCenterCreateWithoutPlansInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutCostCenterInput
    company: CompanyCreateNestedOneWithoutCostCentersInput
  }

  export type CostCenterUncheckedCreateWithoutPlansInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCostCenterInput
  }

  export type CostCenterCreateOrConnectWithoutPlansInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutPlansInput, CostCenterUncheckedCreateWithoutPlansInput>
  }

  export type PlanMarkCreateWithoutPlanInput = {
    id?: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanMarksInput
    workers?: WorkerCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: WorkerUncheckedCreateNestedManyWithoutPlanMarksInput
  }

  export type PlanMarkCreateOrConnectWithoutPlanInput = {
    where: PlanMarkWhereUniqueInput
    create: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput>
  }

  export type PlanMarkCreateManyPlanInputEnvelope = {
    data: PlanMarkCreateManyPlanInput | PlanMarkCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutPlanInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompaniesInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    projects?: ProjectCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    crews?: CrewCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportCreateNestedManyWithoutCompanyInput
    Material?: MaterialCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPlanInput = {
    id?: string
    rut: string
    name: string
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompaniesInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    requirements?: DocumentRequirementUncheckedCreateNestedManyWithoutCompanyInput
    monthlyInfo?: ClientMonthlyInfoUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    crews?: CrewUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutCompanyInput
    costCenters?: CostCenterUncheckedCreateNestedManyWithoutCompanyInput
    DailyReport?: DailyReportUncheckedCreateNestedManyWithoutCompanyInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCompanyInput
    jobTitles?: JobTitleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
  }

  export type ProjectUpsertWithoutPlansInput = {
    update: XOR<ProjectUpdateWithoutPlansInput, ProjectUncheckedUpdateWithoutPlansInput>
    create: XOR<ProjectCreateWithoutPlansInput, ProjectUncheckedCreateWithoutPlansInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPlansInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPlansInput, ProjectUncheckedUpdateWithoutPlansInput>
  }

  export type ProjectUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CostCenterUpsertWithoutPlansInput = {
    update: XOR<CostCenterUpdateWithoutPlansInput, CostCenterUncheckedUpdateWithoutPlansInput>
    create: XOR<CostCenterCreateWithoutPlansInput, CostCenterUncheckedCreateWithoutPlansInput>
    where?: CostCenterWhereInput
  }

  export type CostCenterUpdateToOneWithWhereWithoutPlansInput = {
    where?: CostCenterWhereInput
    data: XOR<CostCenterUpdateWithoutPlansInput, CostCenterUncheckedUpdateWithoutPlansInput>
  }

  export type CostCenterUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutCostCenterNestedInput
    company?: CompanyUpdateOneRequiredWithoutCostCentersNestedInput
  }

  export type CostCenterUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type PlanMarkUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanMarkWhereUniqueInput
    update: XOR<PlanMarkUpdateWithoutPlanInput, PlanMarkUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanMarkCreateWithoutPlanInput, PlanMarkUncheckedCreateWithoutPlanInput>
  }

  export type PlanMarkUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanMarkWhereUniqueInput
    data: XOR<PlanMarkUpdateWithoutPlanInput, PlanMarkUncheckedUpdateWithoutPlanInput>
  }

  export type PlanMarkUpdateManyWithWhereWithoutPlanInput = {
    where: PlanMarkScalarWhereInput
    data: XOR<PlanMarkUpdateManyMutationInput, PlanMarkUncheckedUpdateManyWithoutPlanInput>
  }

  export type CompanyUpsertWithoutPlanInput = {
    update: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPlanInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
  }

  export type CompanyUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompaniesNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PlanCreateWithoutMarksInput = {
    id?: string
    name: string
    imageUrl: string
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutPlansInput
    costCenter?: CostCenterCreateNestedOneWithoutPlansInput
    company: CompanyCreateNestedOneWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutMarksInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PlanCreateOrConnectWithoutMarksInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutMarksInput, PlanUncheckedCreateWithoutMarksInput>
  }

  export type UserCreateWithoutPlanMarksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyCreateNestedManyWithoutUsersInput
    dailyReports?: DailyReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlanMarksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: string
    allowedSections?: UserCreateallowedSectionsInput | string[]
    assignedProjectIds?: UserCreateassignedProjectIdsInput | string[]
    activeCompanyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUncheckedCreateNestedManyWithoutUsersInput
    dailyReports?: DailyReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlanMarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlanMarksInput, UserUncheckedCreateWithoutPlanMarksInput>
  }

  export type WorkerCreateWithoutPlanMarksInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    crews?: CrewCreateNestedManyWithoutWorkersInput
    company: CompanyCreateNestedOneWithoutWorkersInput
  }

  export type WorkerUncheckedCreateWithoutPlanMarksInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    crews?: CrewUncheckedCreateNestedManyWithoutWorkersInput
  }

  export type WorkerCreateOrConnectWithoutPlanMarksInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput>
  }

  export type PlanUpsertWithoutMarksInput = {
    update: XOR<PlanUpdateWithoutMarksInput, PlanUncheckedUpdateWithoutMarksInput>
    create: XOR<PlanCreateWithoutMarksInput, PlanUncheckedCreateWithoutMarksInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutMarksInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutMarksInput, PlanUncheckedUpdateWithoutMarksInput>
  }

  export type PlanUpdateWithoutMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPlansNestedInput
    costCenter?: CostCenterUpdateOneWithoutPlansNestedInput
    company?: CompanyUpdateOneRequiredWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutPlanMarksInput = {
    update: XOR<UserUpdateWithoutPlanMarksInput, UserUncheckedUpdateWithoutPlanMarksInput>
    create: XOR<UserCreateWithoutPlanMarksInput, UserUncheckedCreateWithoutPlanMarksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlanMarksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlanMarksInput, UserUncheckedUpdateWithoutPlanMarksInput>
  }

  export type UserUpdateWithoutPlanMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUpdateManyWithoutUsersNestedInput
    dailyReports?: DailyReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlanMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUncheckedUpdateManyWithoutUsersNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkerUpsertWithWhereUniqueWithoutPlanMarksInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutPlanMarksInput, WorkerUncheckedUpdateWithoutPlanMarksInput>
    create: XOR<WorkerCreateWithoutPlanMarksInput, WorkerUncheckedCreateWithoutPlanMarksInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutPlanMarksInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutPlanMarksInput, WorkerUncheckedUpdateWithoutPlanMarksInput>
  }

  export type WorkerUpdateManyWithWhereWithoutPlanMarksInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutPlanMarksInput>
  }

  export type DailyReportCreateManyUserInput = {
    id?: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PlanMarkCreateManyUserInput = {
    id?: string
    planId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    crews?: CrewUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutCompanyNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    crews?: CrewUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutCompanyNestedInput
    costCenters?: CostCenterUncheckedUpdateManyWithoutCompanyNestedInput
    DailyReport?: DailyReportUncheckedUpdateManyWithoutCompanyNestedInput
    Material?: MaterialUncheckedUpdateManyWithoutCompanyNestedInput
    Plan?: PlanUncheckedUpdateManyWithoutCompanyNestedInput
    jobTitles?: JobTitleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutDailyReportsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyReportNestedInput
  }

  export type DailyReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanMarkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutMarksNestedInput
    workers?: WorkerUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUncheckedUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyCompanyInput = {
    id?: string
    rut: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    clientId?: string | null
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCompanyInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCompanyInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
  }

  export type DocumentRequirementCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientMonthlyInfoCreateManyCompanyInput = {
    id?: string
    clientId: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerCreateManyCompanyInput = {
    id?: string
    rut: string
    name: string
    role?: string | null
    specialty?: string | null
    email?: string | null
    phone?: string | null
    experienceYears?: number | null
    certifications?: WorkerCreatecertificationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewCreateManyCompanyInput = {
    id?: string
    name: string
    role?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyCompanyInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyCompanyInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    projectId?: string | null
    createdAt?: Date | string
  }

  export type CostCenterCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    budget?: number
    createAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReportCreateManyCompanyInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateManyCompanyInput = {
    id?: string
    code?: string | null
    name: string
    unit: string
    minStock?: number
    currentStock?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanCreateManyCompanyInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobTitleCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyReports?: DailyReportUpdateManyWithoutUserNestedInput
    planMarks?: PlanMarkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyReports?: DailyReportUncheckedUpdateManyWithoutUserNestedInput
    planMarks?: PlanMarkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowedSections?: UserUpdateallowedSectionsInput | string[]
    assignedProjectIds?: UserUpdateassignedProjectIdsInput | string[]
    activeCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    requirements?: DocumentRequirementUncheckedUpdateManyWithoutClientNestedInput
    monthlyInfo?: ClientMonthlyInfoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutProjectsNestedInput
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentRequirementUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutRequirementsNestedInput
    documents?: DocumentUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMonthlyInfoUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMonthlyInfoNestedInput
  }

  export type ClientMonthlyInfoUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMonthlyInfoUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUpdateManyWithoutWorkersNestedInput
    planMarks?: PlanMarkUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUncheckedUpdateManyWithoutWorkersNestedInput
    planMarks?: PlanMarkUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    workers?: WorkerUpdateManyWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMovementsNestedInput
    project?: ProjectUpdateOneWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutCostCenterNestedInput
    plans?: PlanUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCostCenterNestedInput
    plans?: PlanUncheckedUpdateManyWithoutCostCenterNestedInput
  }

  export type CostCenterUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyReportsNestedInput
    project?: ProjectUpdateOneWithoutDailyReportsNestedInput
  }

  export type DailyReportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    minStock?: FloatFieldUpdateOperationsInput | number
    currentStock?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPlansNestedInput
    costCenter?: CostCenterUpdateOneWithoutPlansNestedInput
    marks?: PlanMarkUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marks?: PlanMarkUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobTitleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    progress?: number
    budget?: number
    address?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    workerIds?: ProjectCreateworkerIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    projectId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentCreateManyClientInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type DocumentRequirementCreateManyClientInput = {
    id?: string
    name: string
    description?: string | null
    month?: number | null
    year?: number | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ClientMonthlyInfoCreateManyClientInput = {
    id?: string
    month: number
    year: number
    edpDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProjectNestedInput
    plans?: PlanUpdateManyWithoutProjectNestedInput
    company?: CompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    dailyReports?: DailyReportUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutProjectNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProjectNestedInput
    plans?: PlanUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    budget?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerIds?: ProjectUpdateworkerIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentRequirementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutRequirementNestedInput
    company?: CompanyUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type DocumentRequirementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type DocumentRequirementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientMonthlyInfoUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMonthlyInfoNestedInput
  }

  export type ClientMonthlyInfoUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientMonthlyInfoUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    edpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewCreateManyProjectInput = {
    id?: string
    name: string
    role?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InvoiceCreateManyProjectInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    costCenterId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DailyReportCreateManyProjectInput = {
    id?: string
    userId: string
    date: Date | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    clientId?: string | null
    createdAt?: Date | string
    requirementId?: string | null
    status?: string
    companyId: string
  }

  export type PurchaseOrderCreateManyProjectInput = {
    id?: string
    number: string
    provider: string
    date: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InventoryMovementCreateManyProjectInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    materialId: string
    createdAt?: Date | string
    companyId: string
  }

  export type PlanCreateManyProjectInput = {
    id?: string
    name: string
    imageUrl: string
    costCenterId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type CrewUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUpdateManyWithoutCrewsNestedInput
    company?: CompanyUpdateOneRequiredWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    workers?: WorkerUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyReportsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyReportNestedInput
  }

  export type DailyReportUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    requirement?: DocumentRequirementUpdateOneWithoutDocumentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMovementsNestedInput
    company?: CompanyUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costCenter?: CostCenterUpdateOneWithoutPlansNestedInput
    marks?: PlanMarkUpdateManyWithoutPlanNestedInput
    company?: CompanyUpdateOneRequiredWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    marks?: PlanMarkUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceCreateManyCostCenterInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    relatedInvoiceId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type PlanCreateManyCostCenterInput = {
    id?: string
    name: string
    imageUrl: string
    projectId?: string | null
    stages?: number
    systemType?: string | null
    installationType?: string | null
    installationDetail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InvoiceUpdateWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedInvoice?: InvoiceUpdateOneWithoutRelatedByInvoicesNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanUpdateWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPlansNestedInput
    marks?: PlanMarkUpdateManyWithoutPlanNestedInput
    company?: CompanyUpdateOneRequiredWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    marks?: PlanMarkUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutCostCenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: IntFieldUpdateOperationsInput | number
    systemType?: NullableStringFieldUpdateOperationsInput | string | null
    installationType?: NullableStringFieldUpdateOperationsInput | string | null
    installationDetail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCrewsNestedInput
    company?: CompanyUpdateOneRequiredWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUncheckedUpdateManyWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanMarkUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutMarksNestedInput
    user?: UserUpdateOneRequiredWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanMarkUncheckedUpdateManyWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planMarks?: PlanMarkUpdateManyWithoutWorkersNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    planMarks?: PlanMarkUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type InvoiceCreateManyRelatedInvoiceInput = {
    id?: string
    number: string
    date: Date | string
    dueDate?: Date | string | null
    status?: string
    type: string
    emissionType: string
    purchaseOrderNumber?: string | null
    dispatchGuideNumber?: string | null
    netAmount: number
    taxAmount: number
    totalAmount: number
    clientId?: string | null
    projectId?: string | null
    costCenterId?: string | null
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutRelatedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutInvoicesNestedInput
    project?: ProjectUpdateOneWithoutInvoicesNestedInput
    costCenter?: CostCenterUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUpdateManyWithoutRelatedInvoiceNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRelatedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    relatedByInvoices?: InvoiceUncheckedUpdateManyWithoutRelatedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutRelatedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    emissionType?: StringFieldUpdateOperationsInput | string
    purchaseOrderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchGuideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    netAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenterId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    total: number
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type DocumentCreateManyRequirementInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    clientId?: string | null
    createdAt?: Date | string
    status?: string
    companyId: string
  }

  export type DocumentUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateManyMaterialInput = {
    id?: string
    type: string
    quantity: number
    date?: Date | string
    description?: string | null
    projectId?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type InventoryMovementUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInventoryMovementsNestedInput
    company?: CompanyUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanMarkCreateManyPlanInput = {
    id?: string
    userId: string
    x: number
    y: number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: string
    date?: Date | string
    meters?: number
    comment?: string | null
    imageUrl?: string | null
    stage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanMarkUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanMarksNestedInput
    workers?: WorkerUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: WorkerUncheckedUpdateManyWithoutPlanMarksNestedInput
  }

  export type PlanMarkUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    points?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutPlanMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crews?: CrewUpdateManyWithoutWorkersNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateWithoutPlanMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    crews?: CrewUncheckedUpdateManyWithoutWorkersNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutPlanMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    rut?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: WorkerUpdatecertificationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}